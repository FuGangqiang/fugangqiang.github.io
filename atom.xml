<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fugangqiang.github.io</id>
  <title>Fu</title>
  <updated>2021-11-02T12:16:36+08:00</updated>
  <subtitle>Simple is Beautiful!</subtitle>
  <icon>/media/favicon.png</icon>
  <logo>/media/favicon.png</logo>
  <link rel="alternate" type="text/html" href="https://fugangqiang.github.io" />
  <link rel="self" type="application/atom+xml" href="https://fugangqiang.github.io/atom.xml" />
  <generator uri="https://github.com/FuGangqiang/mdblog.rs">mdblog.rs</generator>
  <entry>
    <id>https://fugangqiang.github.io/posts/linux/gentoo/Gentoo%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html</id>
    <title>Gentoo 系统安装</title>
    <updated>2021-11-01T19:11:23+08:00</updated>
    <published>2021-11-01T19:11:23+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/gentoo/Gentoo%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <summary>前天开始在家用笔记本上安装 Gentoo Linux 系统， 并没有想像的复杂，步骤得当，很容易安装成功， 现将安装经历总结如下：...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>前天开始在家用笔记本上安装 Gentoo Linux 系统，
并没有想像的复杂，步骤得当，很容易安装成功，
现将安装经历总结如下：</p>
<h2>安装前注意事项</h2>
<ul>
<li>本文安装方法不适用于虚拟机安装，虚拟机安装需要配置不同的内核参数，应该还有其他注意事项。</li>
<li>如果是新手，需提前阅读、理解官方 Handbook 安装步骤，与网上一些同学安装方法进行比对更佳。</li>
<li>如果不熟悉内核配置，建议用 <code>genkernel</code> 工具来编译、安装内核。</li>
<li>安装前，建议先阅读一下 portage 的使用及原理，使用 portage 相关命令遇到报错时会很有用。</li>
<li>在安装过程中，如果安装失败，可以通过启动 U 盘，重新 chroot 进去，修复系统</li>
</ul>
<p>gentoo 安装文档参考：</p>
<ul>
<li><a href="https://wiki.gentoo.org/wiki/Handbook:Main_Page">Handbook</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Quick_Installation_Checklist">Quick Installation Checklist</a></li>
</ul>
<h2>搭建环境</h2>
<ul>
<li>amd64 架构</li>
<li>gpt 分区</li>
<li>gentoo</li>
<li>systemd-boot 引导加载</li>
<li>systemd 初始化进程</li>
</ul>
<h2>安装基本步骤</h2>
<ul>
<li>制作 Linux 启动 U 盘</li>
<li>BIOS 启动选项设置</li>
<li>安装准备</li>
<li>磁盘分区、格式化</li>
<li>下载、解压 Gentoo Stage3 压缩文件</li>
<li>配置修改</li>
<li>chroot</li>
<li>更新系统</li>
<li>编译 Linux 内核</li>
<li>建立 fstab 文件</li>
<li>配置系统</li>
<li>安装引导程序</li>
<li>重启</li>
<li>安装桌面系统</li>
<li>清理系统</li>
</ul>
<h2>制作 Linux 启动 U 盘</h2>
<p>不建议用 Gentoo 官方提供的启动盘镜像，
因为安装系统时，需要手动输入许多命令，
这些命令可以通过网页文档轻松复制得到，
使用有图形化可引导的 Linux 启动 U 盘，
可以节省很多时间，
考察一番后，选择了 manjaro-xfce iso 镜像文件来制作启动盘，
下载网址为 <a href="https://manjaro.org/download/">https://manjaro.org/download/</a>。</p>
<p>下载完毕后，校验下载镜像文件是否有误：</p>
<pre><code>sha1sum manjaro-xfce-21.1.4-210927-linux513.iso
</code></pre>
<p>检测 hash 字符串，确保与官方网站一致。</p>
<p>dd 命令制作 USB 启动盘：</p>
<pre><code>dd if=./manjaro-xfce-21.1.4-210927-linux513.iso of=/dev/sdc bs=4M status=progress oflag=sync
</code></pre>
<p><code>dd</code> 命令是 Linux 平台下的，如果需要在 Windows 下制作启动盘需使用 <code>Rufus</code> 工具。</p>
<h2>BIOS 启动选项设置</h2>
<p>将 U 盘插入笔记本，开机，当刚出现开机画面时，按 <code>F2</code>进入 BIOS 系统，这里有些系统有可能是其他键。</p>
<p>将 Boot Mode 设为 UEFI Mode，关闭 Secure Boot。</p>
<p>调整优先从 U 盘启动。</p>
<p>保存设置并退出。</p>
<p>进入开机画面，此时显示的就是启动 U 盘系统的加载画面。</p>
<h2>安装准备</h2>
<p>进入 U 盘的 Manjaro Linux 系统后，打开终端和浏览器，
如果使用 WiFi 联网，需要选择设置 WiFi 网络。</p>
<p>在浏览器中可以打开 Gentoo Handbook， 一边看文档，一边复制命令在终端执行。</p>
<p>在终端中切换到 root 用户环境：</p>
<pre><code>su
</code></pre>
<h2>磁盘分区、格式化</h2>
<p>我笔记本里面只有一个 238GiB 固态硬盘，分区方案如下：</p>
<table><thead><tr><th>分区</th><th>挂载路径</th><th>类型</th><th>大小</th></tr></thead><tbody>
<tr><td>boot 分区</td><td>/boot</td><td>fat32</td><td>512MiB</td></tr>
<tr><td>swap 分区</td><td>linux swap</td><td>swap</td><td>4GiB</td></tr>
<tr><td>root 分区</td><td>/</td><td>ext4</td><td>100GiB</td></tr>
<tr><td>home 分区</td><td>/home</td><td>ext4</td><td>100GiB</td></tr>
<tr><td>backup 分区</td><td>不挂载，备用</td><td>ext4</td><td>34GiB</td></tr>
</tbody></table>
<p>注意这里单位是 GiB，而不是 GB。</p>
<h3>查看分区列表</h3>
<p>磁盘分区官方文档用的是 <code>fdisk</code>，本文用的是 <code>parted</code> 命令。</p>
<p>列出系统所有磁盘分区情况：</p>
<pre><code>parted -l
</code></pre>
<p>我这里列出两个磁盘：</p>
<ul>
<li>/dev/sda       30GiB       // USB 启动盘</li>
<li>/dev/nvme0n1   256GiB      // 笔记本固态硬盘</li>
</ul>
<p>注意这里列表里面的单位是 GB，而不是 GiB。</p>
<h3>进入分区命令</h3>
<p>准备将 gentoo 系统安装在笔记本的固态硬盘上面，所以对 <code>/dev/nvme0n1</code> 磁盘进行分区：</p>
<pre><code>parted /dev/nvme0n1
</code></pre>
<p>进入 parted 命令模式，下面所有磁盘分区操作都是在 parted 命令模式下输入。</p>
<h3>修改成 GPT 分区表</h3>
<pre><code>(parted) mklabel GPT
</code></pre>
<p>出现警告「硬盘数据将会全部丢失」，回答 Yes</p>
<h3>创建分区</h3>
<pre><code>(parted) mkpart boot fat32 1MiB 512MiB
(parted) mkpart swap linux-swap 512MiB 4GiB
(parted) mkpart root ext4 4GiB 104GiB
(parted) mkpart home ext4 104GiB 204GiB
(parted) mkpart backup ext4 204GiB 100%
(parted) set 1 esp on
(parted) quit
</code></pre>
<p>注意这里单位是 GiB，而不是 GB。</p>
<h3>格式化分区</h3>
<pre><code>mkfs.fat -F 32 /dev/nvme0n1p1
mkswap /dev/nvme0n1p2
mkfs.ext4 /dev/nvme0n1p3
mkfs.ext4 /dev/nvme0n1p4
mkfs.ext4 /dev/nvme0n1p5
</code></pre>
<h2>下载、解压 Gentoo Stage3 压缩文件</h2>
<h3>挂载主分区</h3>
<pre><code>swapon /dev/nvme0n1p2
mkdir -p /mnt/gentoo
mount /dev/nvme0n1p3 /mnt/gentoo
</code></pre>
<h3>下载 Gentoo Stage3 压缩文件</h3>
<p>可以直接从官网下载，为了加快下载速度，我是用的清华源：</p>
<pre><code>cd /mnt/gentoo
wget https://www.mirrorservice.org/sites/distfiles.gentoo.org//releases/amd64/autobuilds/20211024T170536Z/stage3-amd64-systemd-20211024T170536Z.tar.xz
</code></pre>
<p>验证下载的 gentoo stage3 包：</p>
<pre><code>sha512sum stage3-amd64-systemd-20211024T170536Z.tar.xz
# 相对应 hash 地址：https://mirror.isoc.org.il/pub/gentoo/releases/amd64/autobuilds/20211024T170536Z/stage3-amd64-systemd-20211024T170536Z.tar.xz.DIGESTS
# 检测 hash 是否与官网提供的一致
</code></pre>
<h3>解压 Gentoo Stage3 压缩文件</h3>
<p>检测如果一致，说明下载正确，可以进行解压操作：</p>
<pre><code>tar xpvf stage3-amd64-systemd-20211024T170536Z.tar.xz --xattrs-include='*.*' --numeric-owner
</code></pre>
<h2>配置修改</h2>
<h3>修改 <code>portage/make.conf</code> 文件</h3>
<pre><code>nano -w /mnt/gentoo/etc/portage/make.conf
</code></pre>
<p>修改内容如下：</p>
<pre><code>COMMON_FLAGS=&quot;-march=native -O2 -pipe&quot;
CFLAGS=&quot;${COMMON_FLAGS}&quot;
CXXFLAGS=&quot;${COMMON_FLAGS}&quot;

DISTDIR=&quot;/var/cache/distfiles&quot;
PKGDIR=&quot;/var/cache/binpkgs&quot;

MAKEOPTS=&quot;-j8&quot;
ACCEPT_LICENSE=&quot;*&quot;
GENTOO_MIRRORS=&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo&quot;
</code></pre>
<p>其中：</p>
<ul>
<li><code>MAKEOPTS</code> 里面的数字与 CPU 核数对应，加快编译速度，</li>
<li><code>GENTOO_MIRRORS</code> 使用的清华源，加快下载速度</li>
</ul>
<h3>修改 <code>portage/repos.conf</code> 文件</h3>
<pre><code>mkdir --parents /mnt/gentoo/etc/portage/repos.conf
cp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf
nano -w /mnt/gentoo/etc/portage/repos.conf/gentoo.conf
</code></pre>
<p>修改内容如下：</p>
<pre><code>[DEFAULT]
main-repo = gentoo

[gentoo]
location = /var/db/repos/gentoo
sync-type = rsync
sync-uri = rsync://rsync.gentoo.org/gentoo-portage
auto-sync = yes
sync-rsync-verify-jobs = 1
sync-rsync-verify-metamanifest = yes
sync-rsync-verify-max-age = 24
sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc
sync-openpgp-key-refresh-retry-count = 40
sync-openpgp-key-refresh-retry-overall-timeout = 1200
sync-openpgp-key-refresh-retry-delay-exp-base = 2
sync-openpgp-key-refresh-retry-delay-max = 60
sync-openpgp-key-refresh-retry-delay-mult = 4
</code></pre>
<h3>修改 <code>resolv.conf</code> 文件</h3>
<pre><code>cp --dereference /etc/resolv.conf /mnt/gentoo/etc/
</code></pre>
<h2>chroot</h2>
<pre><code>mount --types proc /proc /mnt/gentoo/proc
mount --rbind /sys /mnt/gentoo/sys
mount --make-rslave /mnt/gentoo/sys
mount --rbind /dev /mnt/gentoo/dev
mount --make-rslave /mnt/gentoo/dev
mount --bind /run /mnt/gentoo/run
mount --make-slave /mnt/gentoo/run
chroot /mnt/gentoo /bin/bash
source /etc/profile
export PS1=&quot;(chroot) ${PS1}&quot;
</code></pre>
<p>挂载 boot 分区：</p>
<pre><code>mount /dev/nvme0n1p1 /boot
</code></pre>
<h2>更新系统</h2>
<h3>同步 ebuild 库</h3>
<pre><code>emerge-webrsync
emerge --sync
</code></pre>
<h3>选择系统 profile</h3>
<pre><code>eselect profile list
eselect profile set NUMBER
</code></pre>
<p>这里根据自己的需要，选择了 systemd 的那个 profile</p>
<h3>systemd-boot 预设置</h3>
<pre><code>echo &quot;sys-apps/systemd gnuefi&quot; &gt;&gt; /etc/portage/package.use/systemdboot
</code></pre>
<h3>升级系统</h3>
<pre><code>emerge -a --update --deep --newuse @world
</code></pre>
<h2>编译 Linux 内核</h2>
<pre><code>emerge --ask sys-kernel/linux-firmware
emerge --ask sys-kernel/gentoo-sources
eselect kernel list
eselect kernel set NUMBER
</code></pre>
<ul>
<li>这里的 <code>NUMBER</code> 为选择的内核编号</li>
</ul>
<h3>手动编译安装</h3>
<pre><code>cd /usr/src/linux
make menuconfig
make -j5 &amp;&amp; make modules_install &amp;&amp; make install

# 安装 initramfs
emerge --ask sys-kernel/genkernel
genkernel --install --kernel-config=/path/to/used/kernel.config initramfs
</code></pre>
<h3>工具辅助编译安装</h3>
<p>建议新手用 <code>genkernel</code> 进行编译、安装内核：</p>
<pre><code>genkernel --install --kernel-config=/path/to/used/kernel.config all
</code></pre>
<p>查看生成的内核文件和 initramfs:</p>
<pre><code>ls /boot/vmlinuz* /boot/initramfs*
</code></pre>
<h2>建立 fstab 文件</h2>
<p>查看各分区的 UUID 和 PARTUUID:</p>
<pre><code>blkid
</code></pre>
<p>创建 fstab 文件：</p>
<pre><code>nano -w /etc/fstab
</code></pre>
<p>根据磁盘分区情况设置文件内容如下：</p>
<pre><code>UUID=XXX-XXX    /          ext4       rw,relatime	0 1
UUID=XXX-XXX    /boot      vfat       defaults     0 0
UUID=XXX-XXX    none       swap       sw           0 0
UUID=XXX-XXX    /home      ext4       defaults     0 2
</code></pre>
<h2>配置系统</h2>
<h3>用户配置</h3>
<pre><code>passwd   root
useradd -m -G wheel fu
passwd  fu
</code></pre>
<h3>语言本地化配置</h3>
<pre><code>echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.GB18030 GB18030&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.GBK GBK&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN GB2312&quot; &gt;&gt; /etc/locale.gen
locale-gen
localectl set-locale en_US.utf8
</code></pre>
<h3>时区配置</h3>
<pre><code>timedatectl set-timezone Asia/Shanghai
</code></pre>
<h3>主机名配置</h3>
<pre><code>hostnamectl set-hostname Gentoo
</code></pre>
<h3>网络配置</h3>
<p>使用 systemd-networkd 的话需要确保 <code>/etc/resolv.conf</code> 是一个软链接，链接到 <code>/run/systemd/network/resolv.conf</code>。</p>
<h4>有线网络</h4>
<p>创建网络配置文件：</p>
<pre><code>nano -w /etc/systemd/network/20-wired.network
</code></pre>
<p>内容如下：</p>
<pre><code>[Match]
Name=enp1s0

[Network]
DHCP=yes
</code></pre>
<p>其中：</p>
<ul>
<li><code>enp1s0</code> 是无线网卡名，可以通过 <code>ip link</code> 查看得到</li>
</ul>
<p>开机启动联网：</p>
<pre><code>systemctl enable systemd-networkd.service
</code></pre>
<h4>无线网络</h4>
<p>安装、配置 wpa_passphrase：</p>
<pre><code>emerge --ask net-wireless/wpa_supplicant
wpa_passphrase MyNetwork SuperSecretPassphrase &gt; /etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf
systemctl enable wpa_supplicant@wlp2s0.conf
</code></pre>
<p>其中：</p>
<ul>
<li><code>wlp2s0</code> 是无线网卡名，可以通过 <code>ip link</code> 查看得到</li>
<li><code>MyNetwork</code> 是无线网络名</li>
<li><code>SuperSecretPassphrase</code> 是无限网络密码</li>
</ul>
<p>创建网络配置文件：</p>
<pre><code>nano -w /etc/systemd/network/25-wireless.network
</code></pre>
<p>内容如下：</p>
<pre><code>[Match]
Name=wlp2s0

[Network]
DHCP=yes
</code></pre>
<p>开机启动联网：</p>
<pre><code>systemctl enable systemd-networkd.service
</code></pre>
<h3>NetworkManager 联网</h3>
<p>最简单的联网方法就是用 NetworkManager，但是它比较重。</p>
<p>修改 <code>/etc/portage/make.conf</code> 的 <code>USE</code> 选项：</p>
<pre><code>USE=&quot;${USE} networkmanager&quot;
</code></pre>
<p>安装 NetworkManager：</p>
<pre><code>emerge --ask --deep --new-use @world
emerge --ask net-misc/networkmanager
</code></pre>
<p>修改普通用户组：</p>
<pre><code>usermod -a -G plugdev fu
</code></pre>
<p>开机启动 NetworkManager：</p>
<pre><code>systemctl enable NetworkManager
</code></pre>
<h3>更新环境</h3>
<pre><code>env-update &amp;&amp; source /etc/profile
</code></pre>
<h2>安装引导程序</h2>
<p>安装 UEFI 启动管理器：</p>
<pre><code>bootctl install
</code></pre>
<p>添加系统启动项：</p>
<pre><code>nano -w /boot/loader/entries/gentoo.conf
</code></pre>
<p>根据 <code>/boot</code> 内的 <code>vmlinuz</code> 和 <code>initramfs</code> 的文件名，设置内容如下：</p>
<pre><code>title Gentoo Linux
linux /vmlinuz-XXX
initrd /initramfs-XXX
options root=PARTUUID=XXXXXX rw init=/lib/systemd/systemd
</code></pre>
<p>其中：</p>
<ul>
<li><code>PARTUUID</code> 是通过 <code>blkid</code> 命令查看分区得到的</li>
</ul>
<p>调整启动管理器配置：</p>
<pre><code>nano -w /boot/loader/loader.conf
</code></pre>
<p>内容如下：</p>
<pre><code>default gentoo
timeout 1
</code></pre>
<h2>重启</h2>
<p>基本系统安装完毕，就可以作为服务器进行配置了。</p>
<pre><code>exit
reboot
</code></pre>
<h2>安装桌面系统</h2>
<pre><code>emerge --ask x11-base/xorg-server
emerge --ask x11-wm/i3
emerge --ask x11-terms/st

echo &quot;exec i3&quot; &gt; ~/.xinitrc
</code></pre>
<p>之后就用 <code>startx</code> 命令就可以进入 i3 图形窗口管理了。</p>
<h2>清理系统</h2>
<pre><code>rm /stage3-amd64-systemd-20211024T170536Z.tar.xz

emerge --depclean
emerge --ask app-portage/gentoolkit
eclean --deep distfiles
eclean --deep packages
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/gentoo/%E4%BD%A0%E5%A5%BD%EF%BC%81Gentoo.html</id>
    <title>你好！Gentoo</title>
    <updated>2021-10-03T17:27:11+08:00</updated>
    <published>2021-10-03T17:27:11+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/gentoo/%E4%BD%A0%E5%A5%BD%EF%BC%81Gentoo.html"/>
    <summary>家用 Archlinux 九年了， 工作开发也使用这个系统， 但 Archlinux 包滚动更新过于激进， 在服务器上选择了 CentOS， Linux 系统使用一直都很和谐。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>家用 Archlinux 九年了，
工作开发也使用这个系统，
但 Archlinux 包滚动更新过于激进，
在服务器上选择了 CentOS，
Linux 系统使用一直都很和谐。</p>
<p>最近 CentOS 开始改变策略，
已经变得不适合服务器了，
于是开始考虑其他 Linux，
考察一番后，集中在三个发行版：</p>
<ul>
<li>Debian</li>
<li>NixOS</li>
<li>Gentoo</li>
</ul>
<p>使用过 Debian，发现一些不是很喜欢的特性：</p>
<ul>
<li>许多应用会被包装一层，配置和使用不与上游保持一致</li>
<li>有些应用安装后会默认启动，启动时又初始化一些默认数据</li>
</ul>
<p>这样自定义一些应用变得麻烦起来，随弃用 Debian。</p>
<p>Gentoo 和 NixOS 都能完美实现同一个应用多版本共存使用，
但是 NixOS 过于激进，弃用了 LFS 标准，包的数量不多，
官方文档不成熟，各应用的配置选项只能通过阅读 Nix 脚本源码来查看使用，
使用上各种不便。</p>
<p>各种抉择后，选择了 Gentoo，
它的 Portage 包管理系统无与伦比，
以至于 Gentoo 被称为元发行版。</p>
<p>Gentoo 几乎可以运行在任何 CPU 类型上，
使用范围极广，
唯一劣势就是基于源码编译安装，安装比较麻烦费时，
但正是由于源码编译安装，Gentoo 可以让你很容易掌控系统的方方面面，
再加上近来 CPU 性能提升、大内存和固态硬盘的普及，极大的缩短了编译时间，
这个劣势也得到了很大缓解。</p>
<p>最近打算先将家用计算机迁移到 Gentoo，认真学习一下 Gentoo 的 Portage 包管理系统，
总结为一系列博客，记录一下这个学习过程。</p>
<p>许久未写博客，感觉又在挖坑...</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/command/linux%20command%E4%B9%8Bunar.html</id>
    <title>linux command之unar</title>
    <updated>2019-11-13T15:01:06+08:00</updated>
    <published>2019-11-13T15:01:06+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/command/linux%20command%E4%B9%8Bunar.html"/>
    <summary>网上下载的一些 zip 文件通常在 linux 下解压会出现文件路径命乱码的问题，需要 `unar` 命令来解压...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>网上下载的一些 zip 文件通常在 linux 下解压会出现文件路径命乱码的问题，需要 <code>unar</code> 命令来解压</p>
<pre><code>pacman -S unarchiver
unar xxx.zip
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/network/tcp-ip-illustrated-v1-the-protocols%E7%AC%94%E8%AE%B0-00.html</id>
    <title>tcp-ip-illustrated-v1-the-protocols笔记-00</title>
    <updated>2018-06-17T18:33:42+08:00</updated>
    <published>2018-06-17T18:33:42+08:00</published>
    <link href="https://fugangqiang.github.io/posts/network/tcp-ip-illustrated-v1-the-protocols%E7%AC%94%E8%AE%B0-00.html"/>
    <summary>最近越发感觉自己在网络方面的知识非常匮乏，很有必要更进一步深入了解一下， 打算从 TCP/IP Illustrated V1: The Protocols 开始看起， 学习过程中再进一步了解 linux 下与网络相关的一系列工具， 并在学习的过程中，认真的做相关笔记。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>最近越发感觉自己在网络方面的知识非常匮乏，很有必要更进一步深入了解一下，
打算从 TCP/IP Illustrated V1: The Protocols 开始看起，
学习过程中再进一步了解 linux 下与网络相关的一系列工具，
并在学习的过程中，认真的做相关笔记。</p>
<p>发现这里埋了一个很大的坑，以后要逼着自己把它填完啦，哈哈...</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html</id>
    <title>rust并发编程：线程高级用法</title>
    <updated>2018-05-14T15:40:59+08:00</updated>
    <published>2018-05-14T15:40:59+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html"/>
    <summary>## Barrier...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <h2>Barrier</h2>
<p><code>Barrier</code> 可以让多个线程同时都执行到在某一点后才能一起再往后执行：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Barrier};

fn main() {
    let mut handles = Vec::with_capacity(10);
    let barrier = Arc::new(Barrier::new(10));

    for _ in 0..10 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!(&quot;before wait&quot;);
            b.wait();
            println!(&quot;after wait&quot;);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
</code></pre>
<p>上面程序会在所有线程都打印出 <code>before wait</code> 后，才会在继续运行，打印 <code>after wait</code>，
这样就保证了所有线程的 <code>after wait</code> 输出在 <code>before wait</code> 输出之后。</p>
<h2>Condition Variables</h2>
<p><code>Condition Variables</code> 通常和 <code>Mutex</code> 一起使用，可以让线程挂起，直到某个条件发生后才会让线程继续执行下去：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let &amp;(ref lock, ref cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        println!(&quot;changing started&quot;);
        *started = true;
        cvar.notify_one();
    });

    let &amp;(ref lock, ref cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!(&quot;started changed&quot;);
}
</code></pre>
<p>上面程序中，如果 <code>started</code> 变量是 <code>false</code>，主线程进入 <code>while</code> 循环体，
并在循环体内释放 <code>started Mutex</code> 锁后挂起线程，直到在其他线程中调用 <code>cvar.notify_one</code> 方法来唤醒主线程，
然后再次利用 <code>while</code> 循环条件判断，直到 <code>started</code> 的值为 <code>true</code> 才会继续执行循环之后的代码。</p>
<h2>Call Once</h2>
<p>有时，多线程中，有些函数只允许被调用一次，通常这类函数是用来在线程间初始化一些全局变量的，
这样，无论哪个线程先调用这个函数，都会保证全局变量只会被初始化一次，
随后的其他线程的调用就忽略会这个函数体了。</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Once, ONCE_INIT};

static mut VAL: usize = 0;
static INIT: Once = ONCE_INIT;

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!(&quot;{}&quot;, unsafe { VAL });
}
</code></pre>
<p>上面程序运行结果取决于哪个线程第一次调用 <code>INIT.call_once</code>，
如果是 <code>handle1</code>，那么结果是 <code>1</code>，
如果是 <code>handle2</code>，那么结果是 <code>2</code>。</p>
<h2>线程局部变量</h2>
<p>rust 中用 <code>thread_local</code> 宏来初始化线程局部变量，并在线程内部用该变量的 <code>with</code> 方法来获取该变量值：</p>
<pre><code class="language-rust">use std::cell::RefCell;
use std::thread;

thread_local! {
    static FOO: RefCell&lt;u32&gt; = RefCell::new(1);
}

fn main() {
    FOO.with(|foo| {
        assert_eq!(*foo.borrow(), 1);
        *foo.borrow_mut() = 2;
    });

    // each thread starts out with the initial value of 1
    thread::spawn(move|| {
        FOO.with(|foo| {
            assert_eq!(*foo.borrow(), 1);
            *foo.borrow_mut() = 3;
        });
    });

    // we retain our original value of 2 despite the child thread
    FOO.with(|foo| {
        assert_eq!(*foo.borrow(), 2);
    });
}
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.html</id>
    <title>rust并发编程：线程消息传递</title>
    <updated>2018-05-02T20:08:06+08:00</updated>
    <published>2018-05-02T20:08:06+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.html"/>
    <summary>rust 不仅可以利用锁来在线程间共享状态，还可以利用消息传递的方式来在线程间共享状态。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>rust 不仅可以利用锁来在线程间共享状态，还可以利用消息传递的方式来在线程间共享状态。</p>
<h2>Multi Producer Single Consumer FIFO Queue</h2>
<p>调用 <code>std::mpsc::channel</code> 会返回一个 tuple 类型，<code>(Sender, Receiver)</code>，
我们可以利用 <code>Sender</code> 在多个线程向通道(channel)里面里面发送消息，
然后可以在一个线程里面利用 <code>Receiver</code> 接收这些消息。</p>
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&amp;tx);
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81.html</id>
    <title>rust并发编程：线程共享状态</title>
    <updated>2018-05-01T18:00:45+08:00</updated>
    <published>2018-05-01T18:00:45+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81.html"/>
    <summary>线程间是经常需要共享数据的， 在 c/c++ 语言中，如果程序编写不当，很容易产生难以被发现的数据竞争 bug， 而 rust 的 `Send`/`Sync` trait 让编译器强制检测代码， 并保证只要程序编译通过，就不会有数据竞争问题，从而实现了线程的并发安全。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>线程间是经常需要共享数据的，
在 c/c++ 语言中，如果程序编写不当，很容易产生难以被发现的数据竞争 bug，
而 rust 的 <code>Send</code>/<code>Sync</code> trait 让编译器强制检测代码，
并保证只要程序编译通过，就不会有数据竞争问题，从而实现了线程的并发安全。</p>
<h2>Send 和 Sync</h2>
<p><code>Send</code> trait 表明拥有该类型的变量的所有权可以从一个线程传递给另一个线程，否则不能传递；
<code>Sync</code> trait 表明拥有该类型的变量可以被多个线程同时引用，否则不能引用。</p>
<p>rust 中的大多类型是 <code>Send</code> 类型的，但是有些类型不是，比如 <code>Rc</code> 类型，
该类型变量只是一个指针，如果允许 <code>Send</code>，就会导致多个线程同时指向了同一块内存，
而它的实现方式对其内部的引用计数的修改又没有做任何线程同步处理，因此会出现数据竞争问题，
所以标准库将 <code>Rc</code> 标记为非 <code>Send</code> 类型，
与它相对的 <code>Arc</code> 类型的实现方式做了线程同步处理，因此 <code>Arc</code> 被标记为 <code>Send</code> 类型。</p>
<p>rust 中的大多类型也都是 <code>Sync</code> 类型，但是有些类型不是，比如 <code>Cell</code> 和 <code>RefCell</code> 类型，
因为这些类型具有内部可变性，如果在多个线程共享这些类型的变量并对其进行修改，
由于它们的实现方式没有做任何线程同步处理，就会导致数据竞争问题，
所以标准库将 <code>Cell</code> 和 <code>RefCell</code> 都标记为非 <code>Sync</code> 类型，
与它们相对的 <code>Mutex</code> 和 <code>RwLock</code> 考虑了线程同步，因此 <code>Mutex</code> 和 <code>RwLock</code> 都被标记为 <code>Sync</code> 类型。</p>
<h2>Arc 共享数据</h2>
<p>由于 <code>Arc</code> 是 <code>Sync</code> 类型，所以我们可以在线程间共享 <code>Arc</code> 类型，代码如下：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::Arc;

fn main() {
    let nums = Arc::new(vec![1, 2, 3]);
    let mut handles = vec![];

    for _ in 0..10 {
        let nums = Arc::clone(&amp;nums);
        let handle = thread::spawn(move || {
                println!(&quot;the nums is {:?}&quot;, nums);
            });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;the nums is {:?}&quot;, nums);
}
</code></pre>
<h2>修改 Arc 共享数据</h2>
<p>与 <code>Rc</code> 类型类似，<code>Arc</code> 类型并不具有内部可变性，因此是不能对其包装对象进行修改的，
因而，rust 语言标准库也提供了对应的具有内部可变性的类型 <code>Mutex</code> 和 <code>RwLock</code>，
它们不像 <code>Cell</code> 和 <code>CellRef</code> 类型，它们的修改是考虑线程同步处理的，
因此利用它们可以在线程间对共享数据进行修改的。</p>
<h3>Mutex 排它锁</h3>
<p><code>Mutex</code> 排它锁允许共享数据在一个时刻只能被一个线程访问、修改，代码如下：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Mutex, Arc};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<h3>RwLock 读写锁</h3>
<p><code>RwLock</code> 读写锁则只允许同一时刻一个线程进行写操作或多个线程同时进行读操作，代码如下：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::Arc;
use std::sync::RwLock;

fn main() {
    let counter = Arc::new(RwLock::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.write().unwrap();
            *num += 1;
            println!(&quot;Write: {}&quot;, num);
        });
        handles.push(handle);
    }

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let num = counter.read().unwrap();
            println!(&quot;Read: {}&quot;, num);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.read().unwrap());
}
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA.html</id>
    <title>rust并发编程：线程创建</title>
    <updated>2018-04-29T17:40:51+08:00</updated>
    <published>2018-04-29T17:40:51+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA.html"/>
    <summary>最近重温了一下 rust 并发编程方面的知识，感觉很有必要总结一下，写个博客系列， 就从线程的创建开始吧。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>最近重温了一下 rust 并发编程方面的知识，感觉很有必要总结一下，写个博客系列，
就从线程的创建开始吧。</p>
<h2>创建线程</h2>
<p>每一个程序默认都会有一个主线程的，也就是运行 <code>main</code> 函数的线程，
我们可以从现有任何线程调用 <code>std::thread::spawn</code> 来创建一个新线程：</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!(&quot;hello concurrency world from {:?}&quot;, thread::current().id());
    });
    handle.join().unwrap();

    println!(&quot;hello concurrency world from {:?}&quot;, thread::current().id());
}
</code></pre>
<p>这段代码输出如下：</p>
<pre><code class="language-plain">hello concurrency world from ThreadId(1)
hello concurrency world from ThreadId(0)
</code></pre>
<p>其中 <code>thread::spawn</code> 接受一个 <code>FnOnce</code> 参数开启一个新线程，
返回调用线程一个 <code>JoinHandle</code>，
我们可以利用这个 <code>JoinHandle</code> 来获取新线程对象，
或等待新线程结束。</p>
<p>每一个线程都有一个唯一标识 <code>id</code>，在任何地方调用 <code>thread::current</code> 来获取当前线程对象，
通过线程对象的 <code>id</code> 方法获取该线程的 <code>id</code>。</p>
<h2>配置线程</h2>
<p>我们也可以调用 <code>thread::Builder</code> 在创建线程前配置线程参数(线程名，线程栈大小)：</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::Builder::new()
        .name(&quot;child&quot;.into())
        .stack_size(32 * 1024)
        .spawn(|| {
            println!(&quot;hello concurrency world from {:?}&quot;, thread::current().name());
        }).unwrap();
    handle.join().unwrap();

    println!(&quot;hello concurrency world from {:?}&quot;, thread::current().name());
}
</code></pre>
<p>这段代码输出如下：</p>
<pre><code class="language-plain">hello concurrency world from Some(&quot;child&quot;)
hello concurrency world from Some(&quot;main&quot;)
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E4%B9%8BRc%E3%80%81Weak.html</id>
    <title>rust之Rc、Weak</title>
    <updated>2018-04-28T14:03:23+08:00</updated>
    <published>2018-04-28T14:03:23+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E4%B9%8BRc%E3%80%81Weak.html"/>
    <summary>rust 语言并没有提供垃圾回收(GC, Garbage Collection )的功能， 不过它提供了最简单的引用计数包装类型 `Rc`，这种引用计数功能也是早期 GC 常用的方法， 但是引用计数不能解决循环引用，所以 rust 同时还提供了 `Weak` 类型用来避免循环引用。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>rust 语言并没有提供垃圾回收(GC, Garbage Collection )的功能，
不过它提供了最简单的引用计数包装类型 <code>Rc</code>，这种引用计数功能也是早期 GC 常用的方法，
但是引用计数不能解决循环引用，所以 rust 同时还提供了 <code>Weak</code> 类型用来避免循环引用。</p>
<h2>Rc、Weak 示例</h2>
<p>首先看一下 <code>Rc</code> 的一个例子：</p>
<pre><code class="language-rust">use std::rc::Rc;

fn main() {
    let a = Rc::new(1);
    println!(&quot;a's reference count is {}&quot;, Rc::strong_count(&amp;a));

    let b = Rc::clone(&amp;a);
    println!(&quot;a's reference count is {} after clone b&quot;, Rc::strong_count(&amp;a));

    let c = Rc::clone(&amp;a);
    println!(&quot;a's reference count is {} after clone c&quot;, Rc::strong_count(&amp;a));
    
    println!(&quot;a = {}, b = {}, c = {}&quot;, a, b, c);
    println!(&quot;b's reference count is {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;c's reference count is {}&quot;, Rc::strong_count(&amp;c));
    
    drop(a);
    println!(&quot;c's reference count is {} after drop `a`&quot;, Rc::strong_count(&amp;c));

    drop(b);
    println!(&quot;c's reference count is {}  after drop `b`&quot;, Rc::strong_count(&amp;c));
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-plain">a's reference count is 1
a's reference count is 2 after clone b
a's reference count is 3 after clone c
a = 1, b = 1, c = 1
b's reference count is 3
c's reference count is 3
c's reference count is 2 after drop `a`
c's reference count is 1  after drop `b`
</code></pre>
<p>从这里可以看出，<code>a</code>、<code>b</code>、<code>c</code> 三个变量同时指向了同一个对象，
这个对象的引用计数会随着 <code>clone</code> 调用而加 1，随着 <code>drop</code> 调用而减 1，
当最后一个变量被 <code>drop</code> 时，引用计数会变为 0，进而触发释放对象被占用的堆内存。</p>
<p>如果 <code>Rc</code> 包装的对象是一个容器类型时，有可能会产生循环引用，比如像下面这样的类型：</p>
<pre><code class="language-rust">struct Car {
    name: String,
    whells: RefCell&lt;Vec&lt;Rc&lt;Wheel&gt;&gt;&gt;,
}

struct Wheel {
    id: i32,
    car: Rc&lt;Car&gt;,
}
</code></pre>
<p>就有可能会出现：<code>Car</code> -&gt; <code>Wheel</code> -&gt; <code>Car</code> 类型的循环引用，
这个循环应用所涉及的对象的引用计数永远都不可能为0, 所占用的内存永远也不会得到释放，
直到进程结束，这样就造成了内存泄露，为了避免这种情况，rust 还提供了 <code>Weak</code> 类型，
和 <code>Rc</code> 类型来协同使用：</p>
<pre><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

struct Car {
    name: String,
    whells: RefCell&lt;Vec&lt;Weak&lt;Wheel&gt;&gt;&gt;,
}

struct Wheel {
    id: i32,
    car: Rc&lt;Car&gt;,
}

fn main() {
    let car: Rc&lt;Car&gt; = Rc::new(
        Car {
            name: &quot;A&quot;.to_string(),
            whells: RefCell::new(vec![]),
        }
    );
    let whell1 = Rc::new(
        Wheel {
            id: 1,
            car: Rc::clone(&amp;car),
        }
    );
    let whell2 = Rc::new(
        Wheel {
            id: 2,
            car: Rc::clone(&amp;car),
        }
    );

    let mut whells = car.whells.borrow_mut();
    whells.push(Rc::downgrade(&amp;whell1));
    whells.push(Rc::downgrade(&amp;whell2));
    drop(whells);

    for whell_weak in car.whells.borrow().iter() {
        let whell = whell_weak.upgrade().unwrap();
        println!(&quot;Whell {} owned by {}&quot;, whell.id, whell.car.name);
    }
}
</code></pre>
<h2>Rc、Weak 原理</h2>
<p>首先我们从源码看看 <code>Rc</code> 和 <code>Weak</code> 的结构：</p>
<pre><code class="language-rust">struct RcBox&lt;T: ?Sized&gt; {
    strong: Cell&lt;usize&gt;,
    weak: Cell&lt;usize&gt;,
    value: T,
}

struct Rc&lt;T: ?Sized&gt; {
    ptr: Shared&lt;RcBox&lt;T&gt;&gt;,
}

struct Weak&lt;T: ?Sized&gt; {
    ptr: Shared&lt;RcBox&lt;T&gt;&gt;,
}
</code></pre>
<p>从上面可以看出：<code>Rc</code> 和 <code>Weak</code> 内存表示并没有什么不同，内部都是存放一个指向 <code>RcBoX</code> 类型的指针，
这个 <code>RcBoX</code> 类型的指针指向堆的某个地方。</p>
<p><code>Rc</code> 和 <code>Weak</code> 的真正不同的地方是针对指向的 <code>RcBox</code> 内部的 <code>strong</code>、<code>weak</code> 的处理上面，
其中 <code>strong</code> 属性用来表示 <code>value</code> 对象的强引用次数(strong reference count)，
<code>weak</code> 属性用来表示 <code>value</code> 对象的弱引用次数(weak reference count，其实是弱引用次数加 1)，
对它们的操作有如下规则：</p>
<ul>
<li>当初始化一个 <code>Rc</code> 时，<code>RcBox.strong</code> 和 <code>RcBox.weak</code> 都被初始化为 1</li>
<li>当执行 <code>Rc::clone</code> 时，<code>RcBox.strong</code> 加 1，
当 <code>drop</code> 一个 <code>Rc</code> 时，<code>RcBox.strong</code> 减 1，
如果此时 <code>RcBox.strong</code> 变为 0，就再将 <code>RcBox.weak</code> 减 1，
如果此时 <code>RcBox.weak</code> 等于 0，就释放 <code>RcBox</code> 类型对象所占用的内存。</li>
<li>当执行 <code>Rc.downgrade</code> 时，返回一个 <code>Weak</code> 引用，并将 <code>RcBox.weak</code> 加 1,
当 <code>drop</code> 一个 <code>Weak</code> 时，<code>RcBox.weak</code> 减 1，当 <code>RcBox.weak</code> 等于 0 时，就释放 <code>RcBox</code> 类型对象所占用的内存。</li>
<li>当执行 <code>Weak.upgrade</code> 时，如果此时 <code>RcBox.strong</code> 为 0 返回 <code>None</code>，
否则 <code>RcBox.strong</code> 加 1，返回 <code>Some(Rc)</code>。</li>
</ul>
<p>这样就可以通过 <code>Rc</code> 和 <code>Weak</code> 像上面协同使用就避免了循环引用了。</p>
<h2>Rc、Weak 限制</h2>
<p>由于 <code>Rc</code> 和 <code>Weak</code> 并没有实现 <code>Send</code> 和 <code>Sync</code> trait，
所以这两种包装类型只能用于单线程中，不能跨线程操作，
如果需要跨线程操作，就需要用到 <code>std::sync::Arc</code> 和 <code>std::sync::Weak</code> 了。</p>
<h2>std::sync::Arc 和 std::sync::Weak 原理</h2>
<p>先看一下它们的源码：</p>
<pre><code class="language-rust">struct ArcInner&lt;T: ?Sized&gt; {
    strong: atomic::AtomicUsize,
    weak: atomic::AtomicUsize,
    data: T,
}

struct Arc&lt;T: ?Sized&gt; {
    ptr: Shared&lt;ArcInner&lt;T&gt;&gt;,
}

struct Weak&lt;T: ?Sized&gt; {
    ptr: Shared&lt;ArcInner&lt;T&gt;&gt;,
}
</code></pre>
<p>它们与 <code>std::rc::Rc</code> 和 <code>std::rc::Weak</code> 类同，
只是 <code>strong</code> 和 <code>weak</code> 的类型使用了线程安全的 atomic 类型，
当然这也带来了一部分性能损失。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E4%B9%8BCell%E3%80%81RefCell.html</id>
    <title>rust之Cell、RefCell</title>
    <updated>2018-04-27T22:24:49+08:00</updated>
    <published>2018-04-27T22:24:49+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E4%B9%8BCell%E3%80%81RefCell.html"/>
    <summary>以前一直困惑于 rust 的 `Cell` 和 `RefCell` 类型， 今天终于理解了， 主要参考了它们的源码实现和一些网上的资料：...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>以前一直困惑于 rust 的 <code>Cell</code> 和 <code>RefCell</code> 类型，
今天终于理解了，
主要参考了它们的源码实现和一些网上的资料：</p>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/4cvc3o/what_are_cell_and_refcell_used_for/">reddit</a></li>
<li><a href="https://stackoverflow.com/questions/30275982/when-i-can-use-either-cell-or-refcell-which-should-i-choose?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">stackoverflow</a></li>
<li><a href="https://ricardomartins.cc/2016/06/08/interior-mutability">Interior mutability in Rust: what, why, how?</a></li>
</ul>
<h2>&amp; 和 &amp;mut</h2>
<p>在讲解 <code>Cell</code> 和 <code>RefCell</code> 之前，不得不说一下 <code>&amp;</code> 和 <code>&amp;mut</code> 类型。</p>
<p>rust 提供了两种引用类型：</p>
<ul>
<li><code>&amp;</code>: shared reference，共享引用</li>
<li><code>&amp;mut</code>: mutable reference，可变引用</li>
</ul>
<p>rust 编译器对这两种引用类型有特别严格的限制：
同一个作用域下，对于资源对象 <code>A</code> 的引用只允许两种情况，
要么是同时存在 n 个共享引用 <code>&amp;</code>，要么只有一个可变引用 <code>&amp;mut</code>，
共享引用不允许对其作任何修改，可变引用可以修改。</p>
<p>rust 的 borrow checker 会根据这两条规则对代码做编译期检测，
进而检测出代码中可能出现的错误，但是这样的检测又过于严格，
导致有些类型的代码不能编译通过，比如：</p>
<pre><code class="language-rust">fn main() {
    let x = 1;
    let y = &amp;x;
    let z = &amp;x;
    x = 2;
    y = 3;
    z = 4;
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>还有，对于 <code>struct</code> 对象，引用类型的可变性是针对整个值的，并不针对其中的某一个字段，
也就是说一个 <code>struct</code> 类型的共享引用 <code>&amp;</code> 是不能修改这个对象的任何一个字段的，
而一个 <code>struct</code> 类型的可变引用 <code>&amp;mut</code> 可以修改这个对象的任何一个字段，
这样 rust 的 borrow checker 在编译以下代码时也会报错：</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32
}

fn main() {
    let p = Point{x: 1, y: 2};
    let p1 = &amp;p;
    let p2 = &amp;p;
    p1.x = 3;
    p2.x = 4;
    println!(&quot;{:?}&quot;, p);
}
</code></pre>
<p>以上两种类型的代码在 c 语言中经常使用，但是在 rust 语言中就不允许通过了，
为此，rust 语言就引入了 <code>Cell</code> 和 <code>RefCell</code> 两种 wrapper 类型来实现类似的操作。</p>
<p>下面，我们看一下如何用 <code>Cell</code>、<code>RefCell</code> 类型来实现上面两个例子。</p>
<h2>Cell 样例</h2>
<p>例一：</p>
<pre><code class="language-rust">use std::cell::Cell;

fn main() {
    let x = Cell::new(1);
    let y = &amp;x;
    let z = &amp;x;
    x.set(2);
    y.set(3);
    z.set(4);
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>例二：</p>
<pre><code class="language-rust">use std::cell::Cell;

#[derive(Debug)]
struct Point {
    x: Cell&lt;i32&gt;,
    y: i32
}

fn main() {
    let p = Point{x: Cell::new(1), y: 2};
    let p1 = &amp;p;
    let p2 = &amp;p;
    p1.x.set(3);
    p2.x.set(4);
   
    println!(&quot;{:?}&quot;, p);
}
</code></pre>
<h2>RefCell 样例</h2>
<p>例一：</p>
<pre><code class="language-rust">use std::cell::RefCell;

fn main() {
    let x = RefCell::new(1);
    let y = &amp;x;
    let z = &amp;x;
    *x.borrow_mut() = 2;
    *y.borrow_mut() = 3;
    *z.borrow_mut() = 4;
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>例二：</p>
<pre><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct Point {
    x: RefCell&lt;i32&gt;,
    y: i32
}

fn main() {
    let p = Point{x: RefCell::new(1), y: 2};
    let p1 = &amp;p;
    let p2 = &amp;p;
    *p1.x.borrow_mut() = 3;
    *p2.x.borrow_mut() = 4;
   
    println!(&quot;{:?}&quot;, p);
}
</code></pre>
<h2>Cell 和 RefCell 有什么不同？</h2>
<p>从上面看，<code>Cell</code> 和 <code>RefCell</code> 似乎只是表达用法上面有些不同，程序的逻辑方面似乎并没有什么不同，
那为什么 rust 同时提供这两种类型呢？</p>
<p>其实看了源码之后你就可以知道：<code>Cell</code> 比 <code>RefCell</code> 更轻，性能更好，用法更方便，
但是 <code>Cell</code> 只能包装 <code>Copy</code> 类型，而 <code>RefCell</code> 可以包装任何类型，
并且 <code>RefCell</code> 可以获取其内部包装对象的引用，并在运行时检测可变引用的唯一性。</p>
<p>它们的内部结构如下：</p>
<pre><code class="language-rust">struct Cell&lt;T&gt; {
    value: UnsafeCell&lt;T&gt;,     // 内部对象
}

struct RefCell&lt;T: ?Sized&gt; {
    borrow: Cell&lt;usize&gt;,      // 对象引用类别和计数
    value: UnsafeCell&lt;T&gt;,     // 内部对象
}
</code></pre>
<p><code>RefCell</code> 内部维护了一个包装对象的引用计数，
当 <code>RefCell.borrow</code> 获取一个共享引用时，内部引用计数加一，当获取的引用离开作用域时，内部引用计数减一，
当 <code>RefCell.borrow_mut</code> 获取一个可变引用时，首先检测引用技数是否为 0，如果为 0，正常返回，
如果不为 0，直接 panic，其实 <code>RefCell.borrow</code> 时也会做类似的检测，当已经获取了可变引用也是直接 panic，
当然为了避免 panic，我们可以用 <code>RefCell.try_borrow</code> 和 <code>RefCell.try_borrow_mut</code> 来获取一个 <code>Result</code> 类型。</p>
<h2>Cell 和 RefCell 的限制</h2>
<p>因为 <code>Cell</code> 和 <code>RefCell</code> 两种类型都未实现 <code>Sync</code> trait，
所以这两种包装类型只能用于单线程中，不能跨线程操作，
如果需要跨线程操作，就需要用到 <code>Mutex</code> 和 <code>RwLock</code> 了。</p>

        ]]>
    </content>
  </entry>
</feed>
