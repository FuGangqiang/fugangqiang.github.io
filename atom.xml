<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fugangqiang.github.io</id>
  <title>Fu</title>
  <updated>2022-06-07T11:47:06+08:00</updated>
  <subtitle>Simple is Beautiful!</subtitle>
  <icon>/media/favicon.png</icon>
  <logo>/media/favicon.png</logo>
  <link rel="alternate" type="text/html" href="https://fugangqiang.github.io" />
  <link rel="self" type="application/atom+xml" href="https://fugangqiang.github.io/atom.xml" />
  <generator uri="https://github.com/FuGangqiang/mdblog.rs">mdblog.rs</generator>
  <entry>
    <id>https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E8%BF%9B%E9%98%B6.html</id>
    <title>编程语言宏之进阶</title>
    <updated>2022-06-06T11:45:00+08:00</updated>
    <published>2022-06-06T11:45:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E8%BF%9B%E9%98%B6.html"/>
    <summary>所有编程语言的语法设计都有终止的一天， 有了宏系统，语言设计人员可以不停的通过宏系统扩展新语法， 使得编程语言永葆青春，不受语言语法限制。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>所有编程语言的语法设计都有终止的一天，
有了宏系统，语言设计人员可以不停的通过宏系统扩展新语法，
使得编程语言永葆青春，不受语言语法限制。</p>
<p>世事皆有两面性，得失之间相互依存。
宏系统可以极大减少单调冗繁的代码，构造出强大的领域特定语言（DSL, Domain Specific Language）,
但是宏的展开比函数调用更难于调试，使用宏需要极其细心，同时也使代码更难于理解。</p>
<p>正是由于上述原因，上世纪八九十年代及世纪之交，
新出现的编程语言都极力避免使用宏系统，
大多利用语言自省功能来进行元编程，
但最近几年，有些静态语言（rust、crystal、julia、...）又开始引入了宏的高级功能。</p>
<p>上篇博客中我们了解到 C 语言宏只是词法 token 级别的简单替换，
接下来我们通过 lisp 语言和 scheme 来讲解较高级的宏系统，
语法级别的用户自定义替换。</p>
<p>理解本文需要你事先熟悉 lisp 语法，以及 sexp 表达式。</p>
<h2>lisp 中的宏</h2>
<p>lisp 语言有 <code>if</code> 条件基本控制语句，而 <code>unless</code> 条件控制结构就是一个宏，
下面看看 lisp 中如何定义一个 <code>unless</code> 宏：</p>
<pre><code>(defmacro unless (condition body)
  (list 'if ('not condition) body))
</code></pre>
<p>lisp 为了简化 macro 的定义，引入了 <code>quasiquote</code>、<code>unquote</code>、<code>unquote-splicing</code> 简写形式，
下面是用 <code>quasiquote</code> 来定义同样的 <code>unless</code> 宏的方法：</p>
<pre><code>(defmacro unless (condition body)
  `(if (not ,condition) ,body))
</code></pre>
<p>上面两种写法都是定义（defmacro, define macro）一个叫 <code>unless</code> 的宏，
这样，代码中如果遇到 <code>(unless some-condition body)</code> 形式，
都会先将该形式的语法转换成 <code>(if (not some-condition) body)</code> 的形式，
然后由 lisp 解释执行。</p>
<p>上面我们可以看到，lisp 定义宏，类似于定义一个函数，
只是这个函数的参数是宏的语法输入，而函数返回的值就是宏的展开，
而又因为 lisp 的代码和数据具有同构性（这也是 sexp 表达式强大之处），
使得宏的展开定义过程极其容易，这也是 lisp 中宏得到普及的一个原因。</p>
<h2>不卫生宏</h2>
<p>虽然 lisp 中定义宏极其方便简单，
但是使用它却要极其小心，因为它有些缺点，就是<code>不卫生</code>，
也就是说 lisp 中宏的展开极易受到运行时上下文环境的影响，
产生意向不到的结果，以至于报错。</p>
<p>比如来看下面 <code>swap</code> 宏的定义：</p>
<pre><code>(defmacro swap (a, b)
  `(let ((tmp ,a))
    (set! ,a ,b)
    (set! ,b tmp)))
</code></pre>
<p>使用上面的宏，我们会碰到两种类型的错误：</p>
<ol>
<li>宏定义引入了重名的符号绑定问题</li>
<li>宏定义使用了运行环境中被重新绑定的符号引用问题</li>
</ol>
<h4>宏定义引入了重名的符号绑定问题</h4>
<p>使用 swap 宏时，如果其参数与 swap 定义时引入的 <code>tmp</code> 变量重名，
就会导致相关变量作用域被改变的问题：</p>
<pre><code>(define tmp 1)
(define  y 2)
(swap tmp y)
</code></pre>
<p>上面的 <code>(swap tmp y)</code> 在宏展开后就成了：</p>
<pre><code>(let ((tmp tmp))
  (set! tmp y)
  (set! y tmp))
</code></pre>
<p>这样就会使宏不能达到预期效果。</p>
<h4>宏定义使用了运行环境中被重新绑定的符号引用问题</h4>
<p>我们在定义宏时用了 <code>set!</code> 绑定，
如果我们在使用宏时，重新绑定了 <code>set!</code> 符号，也会使宏不能达到预期效果，
如下：</p>
<pre><code>(define x 1)
(define y 2)
(let ((set! display))
  (swap x y)
</code></pre>
<h4>如何使用 lisp 宏</h4>
<p>为了解决上面第 1 个问题，lisp 中引入了 <code>gensym</code> 函数，调用它会生成一个独一无二的符号，
这样就可以保证绝对不会出现重名问题：</p>
<pre><code>(defmacro swap (a, b)
  (let ((tmp (gensym))
    `(let ((,tmp ,a))
      (set! ,a ,b)
      (set! ,b ,tmp)))))

</code></pre>
<p>这样在展开 <code>(swap tmp y)</code> 时，就会展开成：</p>
<pre><code>(let ((&lt;tmp-uniq-symbol&gt; tmp))
  (set! tmp y)
  (set! y &lt;tmp-uniq-symbol&gt;))
</code></pre>
<p>但是，lisp 中对于第2种问题却没有什么较好的解决办法，
只能让程序员小心定义和使用宏，避免出现这种问题。</p>
<h2>scheme 中的卫生宏</h2>
<p>为了彻底解决 lisp 上面出现的两种问题，lisp 语言的一个分支 scheme 引入了<code>卫生宏</code>的概念。</p>
<p>用 scheme 中宏定义的方法来定义 swap 宏如下：</p>
<pre><code>(define-syntax swap
  (syntax-rules ()
    ((swap a b) (let ((tmp a))
                  (set! a b)
                  (set! b tmp)))))
</code></pre>
<p>scheme 中的 <code>syntax-rules</code> 中尽管引入了 tmp 和 set! 符号，
但是 scheme 实现却保证了：</p>
<ul>
<li><code>tmp</code> 在宏扩展时会被重命名，保证唯一性</li>
<li><code>set!</code> 在宏扩展时绑定的对象是宏定义时环境中的 <code>set!</code> 对象</li>
</ul>
<p>这样通过引入 <code>syntax-rules</code> 宏定义，scheme 语言彻底解决了不卫生宏的问题。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E6%A6%82%E5%BF%B5.html</id>
    <title>编程语言宏之概念</title>
    <updated>2022-06-02T15:02:00+08:00</updated>
    <published>2022-06-02T15:02:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E6%A6%82%E5%BF%B5.html"/>
    <summary>很多人不理解宏的概念，其实这与翻译有很大关系， 如果将 `macro` 理解为 `缩写`，就更易懂了，翻译成`缩变`就更合适了。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>很多人不理解宏的概念，其实这与翻译有很大关系，
如果将 <code>macro</code> 理解为 <code>缩写</code>，就更易懂了，翻译成<code>缩变</code>就更合适了。</p>
<p>自然语言中，<code>缩写</code>是简单的替换，
<code>人大</code>就是<code>人民代表大会</code>，
<code>中共</code>就是<code>中国共产党</code>，
<code>GDP</code>就是<code>Gross Domestic Product</code>，翻译过来就是<code>国内生产总值</code>,
编程语言中也存在类似的概念，这就是我们说的<code>宏</code>。</p>
<h2>什么是宏？</h2>
<p>在编程语言中，<code>macro</code>(macro instruction 的简称) 是将某些输入替换成某些输出的规则，
它的输入、输出类型可以是字符、词法 token 或者语法树。</p>
<p>宏可以携带参数，一个或者多个，根据参数的不同，替换为不同的内容，也就是<code>可编程替换</code>。</p>
<p>编程语言中涉及宏的地方有两种：</p>
<ul>
<li>宏的定义：用来定义替换规则</li>
<li>宏的展开：用宏的替换规则将宏的输入展开成宏的输出</li>
</ul>
<h2>宏示例</h2>
<p>许多编程语言有宏的概念，比如 C，TeX，m4，lisp，scheme，julia，scala，rust，以及某些汇编语言等等，
下面我们用 C 语言中的宏来示例宏定义和用法。</p>
<p>比如在 C 语言中定义一个简单的 <code>max</code> 宏如下：</p>
<pre><code>#define max(a,b) ((a) &gt;= (b) ? (a) : (b))
</code></pre>
<p>这里定义了一个名为 <code>max</code> 的宏，
这个宏有两个参数是 <code>a</code> 和 <code>b</code>，
而后面的 <code>((a) &gt;= (b) ? (a) : (b))</code> 用来规定替换 <code>max(a, b)</code> 形式的输出样式。</p>
<p>当在代码中使用 <code>max</code> 宏的时候，根据参数的不同进行替换相应的代码，
比如下面的代码：</p>
<pre><code>i + max(x*y, u-v) + j
</code></pre>
<p>这里 <code>max(x*y, u-v)</code> 就相当于一个编程语言 <code>缩写</code>，
其中 <code>x*y</code> 会匹配到 max 定义中的 <code>a</code> 参数，而 <code>u-v</code> 就匹配到 max 定义中的 <code>b</code> 参数，</p>
<pre><code>max(x*y, u-v)
     |    |
     |    |
     v    v
max( a ,  b )
</code></pre>
<p>然后根据 max 定义，将 <code>max(a, b)</code> 形式的宏调用进行参数替换：</p>
<pre><code>(( a ) &gt;= ( b ) ? ( a ) : ( b ))
   |        |       |       |
   |        |       |       |
   v        v       v       v
((x*y) &gt;= (u-v) ? (x*y) : (u-v))
</code></pre>
<p>整个 <code>i + max(x*y, u-v) + j</code> 最终替换后的结果是：</p>
<pre><code>i + ((x*y) &gt;= (u-v) ? (x*y) : (u-v)) + j
</code></pre>
<h2>更复杂的宏</h2>
<p>当然，C 语言中的宏还是比较简单的，它仅仅是词法 token 级别的替换，
有些编程语言有更复杂，更具有编程性的宏，
它们中的代表是 lisp 语言，lisp 可以说是对宏应用最彻底的一个语言，
这与 lisp 的语法是 sexp(S-expressions, Symbolic EXPression)有关，
具体需要看下一篇博文了。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/minilisp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <title>minilisp源码阅读</title>
    <updated>2022-05-29T20:53:00+08:00</updated>
    <published>2022-05-29T20:53:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/minilisp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <summary>## minilisp 简介...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <h2>minilisp 简介</h2>
<p>minilisp 是一个简单的 lisp 解释器，由 <a href="https://github.com/rui314">Rui Ueyama</a> 实现，
大约 1000 行 C 语言代码，注释很详细，再抛去空行，仅仅 700 多行, 
代码极为精简，REPL(Read-Eval-Print-Loop) 的执行过程也极为清晰简单，
阅读 minilisp 源码，再次惊叹于 lisp 的<code>简单</code>哲学。</p>
<p>minilisp 源码地址：<a href="https://github.com/rui314/minilisp">https://github.com/rui314/minilisp</a></p>
<p>minilisp 实现的功能有：</p>
<ul>
<li>支持基本类型有空值、整数(integer)、符号(symbol)、序对(cons cells)</li>
<li>词法(lexical)作用域</li>
<li>闭包(closure)</li>
<li>if 条件表达式</li>
<li>while 循环表达式</li>
<li>基本函数有：+, -, &lt;, =, eq, println, gensym, macroexpand</li>
<li>函数</li>
<li>宏</li>
<li>复制(copying)算法垃圾收集系统</li>
</ul>
<h2>垃圾收集系统</h2>
<p>minilisp 垃圾收集系统是复制算法类型，其算法由 cheney 1970 年研究提出，
不同于深度优先遍历复制算法，其扫描复制时采用广度优先遍历。</p>
<p>垃圾收集的 root 也极其巧妙，除了全局变量 <code>Symbols</code> 这个符号列表外，
其他的 root 变量全部来自于运行时的函数栈中的临时变量，
更巧妙的是，这些变量可以通过一个单向链表在函数调用栈间进行索引遍历，
这个单向链表的构造是通过下面的 <code>DEFINEx</code> 宏进行生成的：</p>
<pre><code>#define ROOT_END ((void *)-1)

#define ADD_ROOT(size)                          \
    void *root_ADD_ROOT_[size + 2];             \
    root_ADD_ROOT_[0] = root;                   \
    for (int i = 1; i &lt;= size; i++)             \
        root_ADD_ROOT_[i] = NULL;               \
    root_ADD_ROOT_[size + 1] = ROOT_END;        \
    root = root_ADD_ROOT_

#define DEFINE1(var1)                           \
    ADD_ROOT(1);                                \
    Obj **var1 = (Obj **)(root_ADD_ROOT_ + 1)

#define DEFINE2(var1, var2)                     \
    ADD_ROOT(2);                                \
    Obj **var1 = (Obj **)(root_ADD_ROOT_ + 1);  \
    Obj **var2 = (Obj **)(root_ADD_ROOT_ + 2)
</code></pre>
<h2>宏和函数</h2>
<p>minilisp 实现代码中最精彩的地方应该是宏和函数的实现竟然是统一的，
这个应该在其他的 lisp 实现中也类似吧。</p>
<p>宏对象、函数对象表示完全一样，唯一不同的是类型标签(type)：</p>
<pre><code>static Obj *make_function(void *root, Obj **env, int type, Obj **params, Obj **body) {
    assert(type == TFUNCTION || type == TMACRO);
    Obj *r = alloc(root, type, sizeof(Obj *) * 3);
    r-&gt;params = *params;
    r-&gt;body = *body;
    r-&gt;env = *env;
    return r;
}
</code></pre>
<p>宏与函数的调用共用了 <code>apply_func</code> 实现，不同的是，宏的参数不会提前被计算，宏调用返回的列表会再次被 eval 计算，</p>
<pre><code>static Obj *macroexpand(void *root, Obj **env, Obj **obj) {
    if ((*obj)-&gt;type != TCELL || (*obj)-&gt;car-&gt;type != TSYMBOL)
        return *obj;
    DEFINE3(bind, macro, args);
    *bind = find(env, (*obj)-&gt;car);
    if (!*bind || (*bind)-&gt;cdr-&gt;type != TMACRO)
        return *obj;
    *macro = (*bind)-&gt;cdr;
    *args = (*obj)-&gt;cdr;
    return apply_func(root, env, macro, args);
}

static Obj *apply(void *root, Obj **env, Obj **fn, Obj **args) {
    if (!is_list(*args))
        error(&quot;argument must be a list&quot;);
    if ((*fn)-&gt;type == TPRIMITIVE)
        return (*fn)-&gt;fn(root, env, args);
    if ((*fn)-&gt;type == TFUNCTION) {
        DEFINE1(eargs);
        *eargs = eval_list(root, env, args);
        return apply_func(root, env, fn, eargs);
    }
    error(&quot;not supported&quot;);
}
</code></pre>
<p>更让人意向不到的是，宏和函数调用都是通过 <code>env</code> 实现了词法作用域。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/gentoo/Gentoo%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html</id>
    <title>Gentoo 系统安装</title>
    <updated>2021-11-01T19:11:23+08:00</updated>
    <published>2021-11-01T19:11:23+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/gentoo/Gentoo%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <summary>前天开始在家用笔记本上安装 Gentoo Linux 系统， 并没有想像的复杂，步骤得当，很容易安装成功， 现将安装经历总结如下：...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>前天开始在家用笔记本上安装 Gentoo Linux 系统，
并没有想像的复杂，步骤得当，很容易安装成功，
现将安装经历总结如下：</p>
<h2>安装前注意事项</h2>
<ul>
<li>本文安装方法不适用于虚拟机安装，虚拟机安装需要配置不同的内核参数，应该还有其他注意事项。</li>
<li>如果是新手，需提前阅读、理解官方 Handbook 安装步骤，与网上一些同学安装方法进行比对更佳。</li>
<li>如果不熟悉内核配置，建议用 <code>genkernel</code> 工具来编译、安装内核。</li>
<li>安装前，建议先阅读一下 portage 的使用及原理，使用 portage 相关命令遇到报错时会很有用。</li>
<li>在安装过程中，如果安装失败，可以通过启动 U 盘，重新 chroot 进去，修复系统</li>
</ul>
<p>gentoo 安装文档参考：</p>
<ul>
<li><a href="https://wiki.gentoo.org/wiki/Handbook:Main_Page">Handbook</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Quick_Installation_Checklist">Quick Installation Checklist</a></li>
</ul>
<h2>搭建环境</h2>
<ul>
<li>amd64 架构</li>
<li>gpt 分区</li>
<li>gentoo</li>
<li>systemd-boot 引导加载</li>
<li>systemd 初始化进程</li>
</ul>
<h2>安装基本步骤</h2>
<ul>
<li>制作 Linux 启动 U 盘</li>
<li>BIOS 启动选项设置</li>
<li>安装准备</li>
<li>磁盘分区、格式化</li>
<li>下载、解压 Gentoo Stage3 压缩文件</li>
<li>配置修改</li>
<li>chroot</li>
<li>更新系统</li>
<li>编译 Linux 内核</li>
<li>建立 fstab 文件</li>
<li>配置系统</li>
<li>安装引导程序</li>
<li>重启</li>
<li>安装桌面系统</li>
<li>清理系统</li>
</ul>
<h2>制作 Linux 启动 U 盘</h2>
<p>不建议用 Gentoo 官方提供的启动盘镜像，
因为安装系统时，需要手动输入许多命令，
这些命令可以通过网页文档轻松复制得到，
使用有图形化可引导的 Linux 启动 U 盘，
可以节省很多时间，
考察一番后，选择了 manjaro-xfce iso 镜像文件来制作启动盘，
下载网址为 <a href="https://manjaro.org/download/">https://manjaro.org/download/</a>。</p>
<p>下载完毕后，校验下载镜像文件是否有误：</p>
<pre><code>sha1sum manjaro-xfce-21.1.4-210927-linux513.iso
</code></pre>
<p>检测 hash 字符串，确保与官方网站一致。</p>
<p>dd 命令制作 USB 启动盘：</p>
<pre><code>dd if=./manjaro-xfce-21.1.4-210927-linux513.iso of=/dev/sdc bs=4M status=progress oflag=sync
</code></pre>
<p><code>dd</code> 命令是 Linux 平台下的，如果需要在 Windows 下制作启动盘需使用 <code>Rufus</code> 工具。</p>
<h2>BIOS 启动选项设置</h2>
<p>将 U 盘插入笔记本，开机，当刚出现开机画面时，按 <code>F2</code>进入 BIOS 系统，这里有些系统有可能是其他键。</p>
<p>将 Boot Mode 设为 UEFI Mode，关闭 Secure Boot。</p>
<p>调整优先从 U 盘启动。</p>
<p>保存设置并退出。</p>
<p>进入开机画面，此时显示的就是启动 U 盘系统的加载画面。</p>
<h2>安装准备</h2>
<p>进入 U 盘的 Manjaro Linux 系统后，打开终端和浏览器，
如果使用 WiFi 联网，需要选择设置 WiFi 网络。</p>
<p>在浏览器中可以打开 Gentoo Handbook， 一边看文档，一边复制命令在终端执行。</p>
<p>在终端中切换到 root 用户环境：</p>
<pre><code>su
</code></pre>
<h2>磁盘分区、格式化</h2>
<p>我笔记本里面只有一个 238GiB 固态硬盘，分区方案如下：</p>
<table><thead><tr><th>分区</th><th>挂载路径</th><th>类型</th><th>大小</th></tr></thead><tbody>
<tr><td>boot 分区</td><td>/boot</td><td>fat32</td><td>512MiB</td></tr>
<tr><td>swap 分区</td><td>linux swap</td><td>swap</td><td>4GiB</td></tr>
<tr><td>root 分区</td><td>/</td><td>ext4</td><td>100GiB</td></tr>
<tr><td>home 分区</td><td>/home</td><td>ext4</td><td>100GiB</td></tr>
<tr><td>backup 分区</td><td>不挂载，备用</td><td>ext4</td><td>34GiB</td></tr>
</tbody></table>
<p>注意这里单位是 GiB，而不是 GB。</p>
<h3>查看分区列表</h3>
<p>磁盘分区官方文档用的是 <code>fdisk</code>，本文用的是 <code>parted</code> 命令。</p>
<p>列出系统所有磁盘分区情况：</p>
<pre><code>parted -l
</code></pre>
<p>我这里列出两个磁盘：</p>
<ul>
<li>/dev/sda       30GiB       // USB 启动盘</li>
<li>/dev/nvme0n1   256GiB      // 笔记本固态硬盘</li>
</ul>
<p>注意这里列表里面的单位是 GB，而不是 GiB。</p>
<h3>进入分区命令</h3>
<p>准备将 gentoo 系统安装在笔记本的固态硬盘上面，所以对 <code>/dev/nvme0n1</code> 磁盘进行分区：</p>
<pre><code>parted /dev/nvme0n1
</code></pre>
<p>进入 parted 命令模式，下面所有磁盘分区操作都是在 parted 命令模式下输入。</p>
<h3>修改成 GPT 分区表</h3>
<pre><code>(parted) mklabel GPT
</code></pre>
<p>出现警告「硬盘数据将会全部丢失」，回答 Yes</p>
<h3>创建分区</h3>
<pre><code>(parted) mkpart boot fat32 1MiB 512MiB
(parted) mkpart swap linux-swap 512MiB 4GiB
(parted) mkpart root ext4 4GiB 104GiB
(parted) mkpart home ext4 104GiB 204GiB
(parted) mkpart backup ext4 204GiB 100%
(parted) set 1 esp on
(parted) quit
</code></pre>
<p>注意这里单位是 GiB，而不是 GB。</p>
<h3>格式化分区</h3>
<pre><code>mkfs.fat -F 32 /dev/nvme0n1p1
mkswap /dev/nvme0n1p2
mkfs.ext4 /dev/nvme0n1p3
mkfs.ext4 /dev/nvme0n1p4
mkfs.ext4 /dev/nvme0n1p5
</code></pre>
<h2>下载、解压 Gentoo Stage3 压缩文件</h2>
<h3>挂载主分区</h3>
<pre><code>swapon /dev/nvme0n1p2
mkdir -p /mnt/gentoo
mount /dev/nvme0n1p3 /mnt/gentoo
</code></pre>
<h3>下载 Gentoo Stage3 压缩文件</h3>
<p>可以直接从官网下载，为了加快下载速度，我是用的清华源：</p>
<pre><code>cd /mnt/gentoo
wget https://www.mirrorservice.org/sites/distfiles.gentoo.org//releases/amd64/autobuilds/20211024T170536Z/stage3-amd64-systemd-20211024T170536Z.tar.xz
</code></pre>
<p>验证下载的 gentoo stage3 包：</p>
<pre><code>sha512sum stage3-amd64-systemd-20211024T170536Z.tar.xz
# 相对应 hash 地址：https://mirror.isoc.org.il/pub/gentoo/releases/amd64/autobuilds/20211024T170536Z/stage3-amd64-systemd-20211024T170536Z.tar.xz.DIGESTS
# 检测 hash 是否与官网提供的一致
</code></pre>
<h3>解压 Gentoo Stage3 压缩文件</h3>
<p>检测如果一致，说明下载正确，可以进行解压操作：</p>
<pre><code>tar xpvf stage3-amd64-systemd-20211024T170536Z.tar.xz --xattrs-include='*.*' --numeric-owner
</code></pre>
<h2>配置修改</h2>
<h3>修改 <code>portage/make.conf</code> 文件</h3>
<pre><code>nano -w /mnt/gentoo/etc/portage/make.conf
</code></pre>
<p>修改内容如下：</p>
<pre><code>COMMON_FLAGS=&quot;-march=native -O2 -pipe&quot;
CFLAGS=&quot;${COMMON_FLAGS}&quot;
CXXFLAGS=&quot;${COMMON_FLAGS}&quot;

DISTDIR=&quot;/var/cache/distfiles&quot;
PKGDIR=&quot;/var/cache/binpkgs&quot;

MAKEOPTS=&quot;-j8&quot;
ACCEPT_LICENSE=&quot;*&quot;
GENTOO_MIRRORS=&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo&quot;
</code></pre>
<p>其中：</p>
<ul>
<li><code>MAKEOPTS</code> 里面的数字与 CPU 核数对应，加快编译速度，</li>
<li><code>GENTOO_MIRRORS</code> 使用的清华源，加快下载速度</li>
</ul>
<h3>修改 <code>portage/repos.conf</code> 文件</h3>
<pre><code>mkdir --parents /mnt/gentoo/etc/portage/repos.conf
cp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf
nano -w /mnt/gentoo/etc/portage/repos.conf/gentoo.conf
</code></pre>
<p>修改内容如下：</p>
<pre><code>[DEFAULT]
main-repo = gentoo

[gentoo]
location = /var/db/repos/gentoo
sync-type = rsync
sync-uri = rsync://rsync.gentoo.org/gentoo-portage
auto-sync = yes
sync-rsync-verify-jobs = 1
sync-rsync-verify-metamanifest = yes
sync-rsync-verify-max-age = 24
sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc
sync-openpgp-key-refresh-retry-count = 40
sync-openpgp-key-refresh-retry-overall-timeout = 1200
sync-openpgp-key-refresh-retry-delay-exp-base = 2
sync-openpgp-key-refresh-retry-delay-max = 60
sync-openpgp-key-refresh-retry-delay-mult = 4
</code></pre>
<h3>修改 <code>resolv.conf</code> 文件</h3>
<pre><code>cp --dereference /etc/resolv.conf /mnt/gentoo/etc/
</code></pre>
<h2>chroot</h2>
<pre><code>mount --types proc /proc /mnt/gentoo/proc
mount --rbind /sys /mnt/gentoo/sys
mount --make-rslave /mnt/gentoo/sys
mount --rbind /dev /mnt/gentoo/dev
mount --make-rslave /mnt/gentoo/dev
mount --bind /run /mnt/gentoo/run
mount --make-slave /mnt/gentoo/run
chroot /mnt/gentoo /bin/bash
source /etc/profile
export PS1=&quot;(chroot) ${PS1}&quot;
</code></pre>
<p>挂载 boot 分区：</p>
<pre><code>mount /dev/nvme0n1p1 /boot
</code></pre>
<h2>更新系统</h2>
<h3>同步 ebuild 库</h3>
<pre><code>emerge-webrsync
emerge --sync
</code></pre>
<h3>选择系统 profile</h3>
<pre><code>eselect profile list
eselect profile set NUMBER
</code></pre>
<p>这里根据自己的需要，选择了 systemd 的那个 profile</p>
<h3>systemd-boot 预设置</h3>
<pre><code>echo &quot;sys-apps/systemd gnuefi&quot; &gt;&gt; /etc/portage/package.use/systemdboot
</code></pre>
<h3>升级系统</h3>
<pre><code>emerge -a --update --deep --newuse @world
</code></pre>
<h2>编译 Linux 内核</h2>
<pre><code>emerge --ask sys-kernel/linux-firmware
emerge --ask sys-kernel/gentoo-sources
eselect kernel list
eselect kernel set NUMBER
</code></pre>
<ul>
<li>这里的 <code>NUMBER</code> 为选择的内核编号</li>
</ul>
<h3>手动编译安装</h3>
<pre><code>cd /usr/src/linux
make menuconfig
make -j5 &amp;&amp; make modules_install &amp;&amp; make install

# 安装 initramfs
emerge --ask sys-kernel/genkernel
genkernel --install --kernel-config=/path/to/used/kernel.config initramfs
</code></pre>
<h3>工具辅助编译安装</h3>
<p>建议新手用 <code>genkernel</code> 进行编译、安装内核：</p>
<pre><code>genkernel --install --kernel-config=/path/to/used/kernel.config all
</code></pre>
<p>查看生成的内核文件和 initramfs:</p>
<pre><code>ls /boot/vmlinuz* /boot/initramfs*
</code></pre>
<h2>建立 fstab 文件</h2>
<p>查看各分区的 UUID 和 PARTUUID:</p>
<pre><code>blkid
</code></pre>
<p>创建 fstab 文件：</p>
<pre><code>nano -w /etc/fstab
</code></pre>
<p>根据磁盘分区情况设置文件内容如下：</p>
<pre><code>UUID=XXX-XXX    /          ext4       rw,relatime	0 1
UUID=XXX-XXX    /boot      vfat       defaults     0 0
UUID=XXX-XXX    none       swap       sw           0 0
UUID=XXX-XXX    /home      ext4       defaults     0 2
</code></pre>
<h2>配置系统</h2>
<h3>用户配置</h3>
<pre><code>passwd   root
useradd -m -G wheel fu
passwd  fu
</code></pre>
<h3>语言本地化配置</h3>
<pre><code>echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.GB18030 GB18030&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.GBK GBK&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN GB2312&quot; &gt;&gt; /etc/locale.gen
locale-gen
localectl set-locale en_US.utf8
</code></pre>
<h3>时区配置</h3>
<pre><code>timedatectl set-timezone Asia/Shanghai
</code></pre>
<h3>主机名配置</h3>
<pre><code>hostnamectl set-hostname Gentoo
</code></pre>
<h3>网络配置</h3>
<p>使用 systemd-networkd 的话需要确保 <code>/etc/resolv.conf</code> 是一个软链接，链接到 <code>/run/systemd/network/resolv.conf</code>。</p>
<h4>有线网络</h4>
<p>创建网络配置文件：</p>
<pre><code>nano -w /etc/systemd/network/20-wired.network
</code></pre>
<p>内容如下：</p>
<pre><code>[Match]
Name=enp1s0

[Network]
DHCP=yes
</code></pre>
<p>其中：</p>
<ul>
<li><code>enp1s0</code> 是无线网卡名，可以通过 <code>ip link</code> 查看得到</li>
</ul>
<p>开机启动联网：</p>
<pre><code>systemctl enable systemd-networkd.service
</code></pre>
<h4>无线网络</h4>
<p>安装、配置 wpa_passphrase：</p>
<pre><code>emerge --ask net-wireless/wpa_supplicant
wpa_passphrase MyNetwork SuperSecretPassphrase &gt; /etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf
systemctl enable wpa_supplicant@wlp2s0.conf
</code></pre>
<p>其中：</p>
<ul>
<li><code>wlp2s0</code> 是无线网卡名，可以通过 <code>ip link</code> 查看得到</li>
<li><code>MyNetwork</code> 是无线网络名</li>
<li><code>SuperSecretPassphrase</code> 是无限网络密码</li>
</ul>
<p>创建网络配置文件：</p>
<pre><code>nano -w /etc/systemd/network/25-wireless.network
</code></pre>
<p>内容如下：</p>
<pre><code>[Match]
Name=wlp2s0

[Network]
DHCP=yes
</code></pre>
<p>开机启动联网：</p>
<pre><code>systemctl enable systemd-networkd.service
</code></pre>
<h3>NetworkManager 联网</h3>
<p>最简单的联网方法就是用 NetworkManager，但是它比较重。</p>
<p>修改 <code>/etc/portage/make.conf</code> 的 <code>USE</code> 选项：</p>
<pre><code>USE=&quot;${USE} networkmanager&quot;
</code></pre>
<p>安装 NetworkManager：</p>
<pre><code>emerge --ask --deep --new-use @world
emerge --ask net-misc/networkmanager
</code></pre>
<p>修改普通用户组：</p>
<pre><code>usermod -a -G plugdev fu
</code></pre>
<p>开机启动 NetworkManager：</p>
<pre><code>systemctl enable NetworkManager
</code></pre>
<h3>更新环境</h3>
<pre><code>env-update &amp;&amp; source /etc/profile
</code></pre>
<h2>安装引导程序</h2>
<p>安装 UEFI 启动管理器：</p>
<pre><code>bootctl install
</code></pre>
<p>添加系统启动项：</p>
<pre><code>nano -w /boot/loader/entries/gentoo.conf
</code></pre>
<p>根据 <code>/boot</code> 内的 <code>vmlinuz</code> 和 <code>initramfs</code> 的文件名，设置内容如下：</p>
<pre><code>title Gentoo Linux
linux /vmlinuz-XXX
initrd /initramfs-XXX
options root=PARTUUID=XXXXXX rw init=/lib/systemd/systemd
</code></pre>
<p>其中：</p>
<ul>
<li><code>PARTUUID</code> 是通过 <code>blkid</code> 命令查看分区得到的</li>
</ul>
<p>调整启动管理器配置：</p>
<pre><code>nano -w /boot/loader/loader.conf
</code></pre>
<p>内容如下：</p>
<pre><code>default gentoo
timeout 1
</code></pre>
<h2>重启</h2>
<p>基本系统安装完毕，就可以作为服务器进行配置了。</p>
<pre><code>exit
reboot
</code></pre>
<h2>安装桌面系统</h2>
<pre><code>emerge --ask x11-base/xorg-server
emerge --ask x11-wm/i3
emerge --ask x11-terms/st

echo &quot;exec i3&quot; &gt; ~/.xinitrc
</code></pre>
<p>之后就用 <code>startx</code> 命令就可以进入 i3 图形窗口管理了。</p>
<h2>清理系统</h2>
<pre><code>rm /stage3-amd64-systemd-20211024T170536Z.tar.xz

emerge --depclean
emerge --ask app-portage/gentoolkit
eclean --deep distfiles
eclean --deep packages
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/gentoo/%E4%BD%A0%E5%A5%BD%EF%BC%81Gentoo.html</id>
    <title>你好！Gentoo</title>
    <updated>2021-10-03T17:27:11+08:00</updated>
    <published>2021-10-03T17:27:11+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/gentoo/%E4%BD%A0%E5%A5%BD%EF%BC%81Gentoo.html"/>
    <summary>家用 Archlinux 九年了， 工作开发也使用这个系统， 但 Archlinux 包滚动更新过于激进， 在服务器上选择了 CentOS， Linux 系统使用一直都很和谐。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>家用 Archlinux 九年了，
工作开发也使用这个系统，
但 Archlinux 包滚动更新过于激进，
在服务器上选择了 CentOS，
Linux 系统使用一直都很和谐。</p>
<p>最近 CentOS 开始改变策略，
已经变得不适合服务器了，
于是开始考虑其他 Linux，
考察一番后，集中在三个发行版：</p>
<ul>
<li>Debian</li>
<li>NixOS</li>
<li>Gentoo</li>
</ul>
<p>使用过 Debian，发现一些不是很喜欢的特性：</p>
<ul>
<li>许多应用会被包装一层，配置和使用不与上游保持一致</li>
<li>有些应用安装后会默认启动，启动时又初始化一些默认数据</li>
</ul>
<p>这样自定义一些应用变得麻烦起来，随弃用 Debian。</p>
<p>Gentoo 和 NixOS 都能完美实现同一个应用多版本共存使用，
但是 NixOS 过于激进，弃用了 LFS 标准，包的数量不多，
官方文档不成熟，各应用的配置选项只能通过阅读 Nix 脚本源码来查看使用，
使用上各种不便。</p>
<p>各种抉择后，选择了 Gentoo，
它的 Portage 包管理系统无与伦比，
以至于 Gentoo 被称为元发行版。</p>
<p>Gentoo 几乎可以运行在任何 CPU 类型上，
使用范围极广，
唯一劣势就是基于源码编译安装，安装比较麻烦费时，
但正是由于源码编译安装，Gentoo 可以让你很容易掌控系统的方方面面，
再加上近来 CPU 性能提升、大内存和固态硬盘的普及，极大的缩短了编译时间，
这个劣势也得到了很大缓解。</p>
<p>最近打算先将家用计算机迁移到 Gentoo，认真学习一下 Gentoo 的 Portage 包管理系统，
总结为一系列博客，记录一下这个学习过程。</p>
<p>许久未写博客，感觉又在挖坑...</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/command/linux%20command%E4%B9%8Bunar.html</id>
    <title>linux command之unar</title>
    <updated>2019-11-13T15:01:06+08:00</updated>
    <published>2019-11-13T15:01:06+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/command/linux%20command%E4%B9%8Bunar.html"/>
    <summary>网上下载的一些 zip 文件通常在 linux 下解压会出现文件路径命乱码的问题，需要 `unar` 命令来解压...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>网上下载的一些 zip 文件通常在 linux 下解压会出现文件路径命乱码的问题，需要 <code>unar</code> 命令来解压</p>
<pre><code>pacman -S unarchiver
unar xxx.zip
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html</id>
    <title>rust并发编程：线程高级用法</title>
    <updated>2018-05-14T15:40:59+08:00</updated>
    <published>2018-05-14T15:40:59+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html"/>
    <summary>## Barrier...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <h2>Barrier</h2>
<p><code>Barrier</code> 可以让多个线程同时都执行到在某一点后才能一起再往后执行：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Barrier};

fn main() {
    let mut handles = Vec::with_capacity(10);
    let barrier = Arc::new(Barrier::new(10));

    for _ in 0..10 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!(&quot;before wait&quot;);
            b.wait();
            println!(&quot;after wait&quot;);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
</code></pre>
<p>上面程序会在所有线程都打印出 <code>before wait</code> 后，才会在继续运行，打印 <code>after wait</code>，
这样就保证了所有线程的 <code>after wait</code> 输出在 <code>before wait</code> 输出之后。</p>
<h2>Condition Variables</h2>
<p><code>Condition Variables</code> 通常和 <code>Mutex</code> 一起使用，可以让线程挂起，直到某个条件发生后才会让线程继续执行下去：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let &amp;(ref lock, ref cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        println!(&quot;changing started&quot;);
        *started = true;
        cvar.notify_one();
    });

    let &amp;(ref lock, ref cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!(&quot;started changed&quot;);
}
</code></pre>
<p>上面程序中，如果 <code>started</code> 变量是 <code>false</code>，主线程进入 <code>while</code> 循环体，
并在循环体内释放 <code>started Mutex</code> 锁后挂起线程，直到在其他线程中调用 <code>cvar.notify_one</code> 方法来唤醒主线程，
然后再次利用 <code>while</code> 循环条件判断，直到 <code>started</code> 的值为 <code>true</code> 才会继续执行循环之后的代码。</p>
<h2>Call Once</h2>
<p>有时，多线程中，有些函数只允许被调用一次，通常这类函数是用来在线程间初始化一些全局变量的，
这样，无论哪个线程先调用这个函数，都会保证全局变量只会被初始化一次，
随后的其他线程的调用就忽略会这个函数体了。</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Once, ONCE_INIT};

static mut VAL: usize = 0;
static INIT: Once = ONCE_INIT;

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!(&quot;{}&quot;, unsafe { VAL });
}
</code></pre>
<p>上面程序运行结果取决于哪个线程第一次调用 <code>INIT.call_once</code>，
如果是 <code>handle1</code>，那么结果是 <code>1</code>，
如果是 <code>handle2</code>，那么结果是 <code>2</code>。</p>
<h2>线程局部变量</h2>
<p>rust 中用 <code>thread_local</code> 宏来初始化线程局部变量，并在线程内部用该变量的 <code>with</code> 方法来获取该变量值：</p>
<pre><code class="language-rust">use std::cell::RefCell;
use std::thread;

thread_local! {
    static FOO: RefCell&lt;u32&gt; = RefCell::new(1);
}

fn main() {
    FOO.with(|foo| {
        assert_eq!(*foo.borrow(), 1);
        *foo.borrow_mut() = 2;
    });

    // each thread starts out with the initial value of 1
    thread::spawn(move|| {
        FOO.with(|foo| {
            assert_eq!(*foo.borrow(), 1);
            *foo.borrow_mut() = 3;
        });
    });

    // we retain our original value of 2 despite the child thread
    FOO.with(|foo| {
        assert_eq!(*foo.borrow(), 2);
    });
}
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.html</id>
    <title>rust并发编程：线程消息传递</title>
    <updated>2018-05-02T20:08:06+08:00</updated>
    <published>2018-05-02T20:08:06+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.html"/>
    <summary>rust 不仅可以利用锁来在线程间共享状态，还可以利用消息传递的方式来在线程间共享状态。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>rust 不仅可以利用锁来在线程间共享状态，还可以利用消息传递的方式来在线程间共享状态。</p>
<h2>Multi Producer Single Consumer FIFO Queue</h2>
<p>调用 <code>std::mpsc::channel</code> 会返回一个 tuple 类型，<code>(Sender, Receiver)</code>，
我们可以利用 <code>Sender</code> 在多个线程向通道(channel)里面里面发送消息，
然后可以在一个线程里面利用 <code>Receiver</code> 接收这些消息。</p>
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&amp;tx);
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81.html</id>
    <title>rust并发编程：线程共享状态</title>
    <updated>2018-05-01T18:00:45+08:00</updated>
    <published>2018-05-01T18:00:45+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81.html"/>
    <summary>线程间是经常需要共享数据的， 在 c/c++ 语言中，如果程序编写不当，很容易产生难以被发现的数据竞争 bug， 而 rust 的 `Send`/`Sync` trait 让编译器强制检测代码， 并保证只要程序编译通过，就不会有数据竞争问题，从而实现了线程的并发安全。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>线程间是经常需要共享数据的，
在 c/c++ 语言中，如果程序编写不当，很容易产生难以被发现的数据竞争 bug，
而 rust 的 <code>Send</code>/<code>Sync</code> trait 让编译器强制检测代码，
并保证只要程序编译通过，就不会有数据竞争问题，从而实现了线程的并发安全。</p>
<h2>Send 和 Sync</h2>
<p><code>Send</code> trait 表明拥有该类型的变量的所有权可以从一个线程传递给另一个线程，否则不能传递；
<code>Sync</code> trait 表明拥有该类型的变量可以被多个线程同时引用，否则不能引用。</p>
<p>rust 中的大多类型是 <code>Send</code> 类型的，但是有些类型不是，比如 <code>Rc</code> 类型，
该类型变量只是一个指针，如果允许 <code>Send</code>，就会导致多个线程同时指向了同一块内存，
而它的实现方式对其内部的引用计数的修改又没有做任何线程同步处理，因此会出现数据竞争问题，
所以标准库将 <code>Rc</code> 标记为非 <code>Send</code> 类型，
与它相对的 <code>Arc</code> 类型的实现方式做了线程同步处理，因此 <code>Arc</code> 被标记为 <code>Send</code> 类型。</p>
<p>rust 中的大多类型也都是 <code>Sync</code> 类型，但是有些类型不是，比如 <code>Cell</code> 和 <code>RefCell</code> 类型，
因为这些类型具有内部可变性，如果在多个线程共享这些类型的变量并对其进行修改，
由于它们的实现方式没有做任何线程同步处理，就会导致数据竞争问题，
所以标准库将 <code>Cell</code> 和 <code>RefCell</code> 都标记为非 <code>Sync</code> 类型，
与它们相对的 <code>Mutex</code> 和 <code>RwLock</code> 考虑了线程同步，因此 <code>Mutex</code> 和 <code>RwLock</code> 都被标记为 <code>Sync</code> 类型。</p>
<h2>Arc 共享数据</h2>
<p>由于 <code>Arc</code> 是 <code>Sync</code> 类型，所以我们可以在线程间共享 <code>Arc</code> 类型，代码如下：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::Arc;

fn main() {
    let nums = Arc::new(vec![1, 2, 3]);
    let mut handles = vec![];

    for _ in 0..10 {
        let nums = Arc::clone(&amp;nums);
        let handle = thread::spawn(move || {
                println!(&quot;the nums is {:?}&quot;, nums);
            });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;the nums is {:?}&quot;, nums);
}
</code></pre>
<h2>修改 Arc 共享数据</h2>
<p>与 <code>Rc</code> 类型类似，<code>Arc</code> 类型并不具有内部可变性，因此是不能对其包装对象进行修改的，
因而，rust 语言标准库也提供了对应的具有内部可变性的类型 <code>Mutex</code> 和 <code>RwLock</code>，
它们不像 <code>Cell</code> 和 <code>CellRef</code> 类型，它们的修改是考虑线程同步处理的，
因此利用它们可以在线程间对共享数据进行修改的。</p>
<h3>Mutex 排它锁</h3>
<p><code>Mutex</code> 排它锁允许共享数据在一个时刻只能被一个线程访问、修改，代码如下：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Mutex, Arc};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<h3>RwLock 读写锁</h3>
<p><code>RwLock</code> 读写锁则只允许同一时刻一个线程进行写操作或多个线程同时进行读操作，代码如下：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::Arc;
use std::sync::RwLock;

fn main() {
    let counter = Arc::new(RwLock::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.write().unwrap();
            *num += 1;
            println!(&quot;Write: {}&quot;, num);
        });
        handles.push(handle);
    }

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let num = counter.read().unwrap();
            println!(&quot;Read: {}&quot;, num);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.read().unwrap());
}
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA.html</id>
    <title>rust并发编程：线程创建</title>
    <updated>2018-04-29T17:40:51+08:00</updated>
    <published>2018-04-29T17:40:51+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA.html"/>
    <summary>最近重温了一下 rust 并发编程方面的知识，感觉很有必要总结一下，写个博客系列， 就从线程的创建开始吧。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>最近重温了一下 rust 并发编程方面的知识，感觉很有必要总结一下，写个博客系列，
就从线程的创建开始吧。</p>
<h2>创建线程</h2>
<p>每一个程序默认都会有一个主线程的，也就是运行 <code>main</code> 函数的线程，
我们可以从现有任何线程调用 <code>std::thread::spawn</code> 来创建一个新线程：</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!(&quot;hello concurrency world from {:?}&quot;, thread::current().id());
    });
    handle.join().unwrap();

    println!(&quot;hello concurrency world from {:?}&quot;, thread::current().id());
}
</code></pre>
<p>这段代码输出如下：</p>
<pre><code class="language-plain">hello concurrency world from ThreadId(1)
hello concurrency world from ThreadId(0)
</code></pre>
<p>其中 <code>thread::spawn</code> 接受一个 <code>FnOnce</code> 参数开启一个新线程，
返回调用线程一个 <code>JoinHandle</code>，
我们可以利用这个 <code>JoinHandle</code> 来获取新线程对象，
或等待新线程结束。</p>
<p>每一个线程都有一个唯一标识 <code>id</code>，在任何地方调用 <code>thread::current</code> 来获取当前线程对象，
通过线程对象的 <code>id</code> 方法获取该线程的 <code>id</code>。</p>
<h2>配置线程</h2>
<p>我们也可以调用 <code>thread::Builder</code> 在创建线程前配置线程参数(线程名，线程栈大小)：</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::Builder::new()
        .name(&quot;child&quot;.into())
        .stack_size(32 * 1024)
        .spawn(|| {
            println!(&quot;hello concurrency world from {:?}&quot;, thread::current().name());
        }).unwrap();
    handle.join().unwrap();

    println!(&quot;hello concurrency world from {:?}&quot;, thread::current().name());
}
</code></pre>
<p>这段代码输出如下：</p>
<pre><code class="language-plain">hello concurrency world from Some(&quot;child&quot;)
hello concurrency world from Some(&quot;main&quot;)
</code></pre>

        ]]>
    </content>
  </entry>
</feed>
