<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fugangqiang.github.io</id>
  <title>Fu</title>
  <updated>2022-08-17T11:49:53+08:00</updated>
  <subtitle>Simple is Beautiful!</subtitle>
  <icon>/media/favicon.png</icon>
  <logo>/media/favicon.png</logo>
  <link rel="alternate" type="text/html" href="https://fugangqiang.github.io" />
  <link rel="self" type="application/atom+xml" href="https://fugangqiang.github.io/atom.xml" />
  <generator uri="https://github.com/FuGangqiang/mdblog.rs">mdblog.rs</generator>
  <entry>
    <id>https://fugangqiang.github.io/posts/compiler/forward%20forth%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <title>forward forth 源码阅读</title>
    <updated>2022-08-17T11:29:00+08:00</updated>
    <published>2022-08-17T11:29:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/forward%20forth%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <summary>最近涉猎了一下 forth 编程语言，为了理解这个编程语言， 阅读了一个简单的 forth 解释器源码实现， 代码精简到极致，这也许就是 forth 语言的魅力， 地址为 [https://github.com/GithubPrankster/forward](https://github.com/GithubPrankster/forward)。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>最近涉猎了一下 forth 编程语言，为了理解这个编程语言，
阅读了一个简单的 forth 解释器源码实现，
代码精简到极致，这也许就是 forth 语言的魅力，
地址为 <a href="https://github.com/GithubPrankster/forward">https://github.com/GithubPrankster/forward</a>。</p>
<h2>forward 简介</h2>
<p>forward 是一个简单的 forth 语言解释器，大约 160 行 C 语言代码，代码清晰简单，
过去一直认为最简单的编程语言是 lisp，了解 forth 语言后，忽然发现，forth 语言比 lisp 还简单，
山外有山啊！</p>
<p>forward 实现功能有：</p>
<ul>
<li>基本类型只有整数</li>
<li>所有内置操作有<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>.</code>, <code>:</code>, <code>DUP</code>, <code>POP</code>, <code>SPACES</code>, <code>CR</code>, <code>EMIT</code>, <code>SWAP</code></li>
<li>字典和堆栈都是用数组来实现</li>
</ul>
<pre><code>typedef struct{
    char name[64];
    char buf[128];
}expr;

expr funcs[16];
int funcnt = 0;

int stack[16];
int stkcnt = 0;
</code></pre>
<ul>
<li>main 函数就是一个简单的 REPL(Read-Eval-Print-Loop)</li>
</ul>
<pre><code>int main(void)
{
    printf(&quot;FORWARD ver. 0.4, by Uneven Prankster @ 2020\n&quot;);
    char buf[256];
    while(fgets(buf, sizeof buf, stdin)){
        eval(buf);
        printf(&quot; cool.\n&quot;);
    }
    return 0;
}
</code></pre>
<p>遗憾的是，这个解释器实现没有实现 if 分支，和 loop 循环。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/c4%3A%E6%9C%80%E5%B0%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8.html</id>
    <title>c4:最小的C语言解释器</title>
    <updated>2022-08-01T14:34:00+08:00</updated>
    <published>2022-08-01T14:34:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/c4%3A%E6%9C%80%E5%B0%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8.html"/>
    <summary>## 什么是 `C4`...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <h2>什么是 <code>C4</code></h2>
<p><code>C4</code> 是 <code>C in four functions</code> 的缩写，
顾名思义，它仅仅用 4 个函数就实现了一个 <code>C</code> 语言，
具体来说，是实现了一个 <code>C</code> 语言的解释器，当然只是实现了一个 <code>C</code> 语言的子集。</p>
<p>它的代码仓库在：<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>。</p>
<p>看代码，仅仅 500 多行，
更厉害之处在于它实现了自举，
也就是说，它可以用它自己来编译解释它自己的实现代码，
可以说麻雀虽小，五脏俱全，是学写编译原理的绝佳范例。</p>
<h2>如何阅读理解 <code>C4</code> 代码</h2>
<p>作者对代码进行了极致精简，
代码行数以至于仅有 500 多行，
造成了理解上的困难，
不过网上已经有了各种 <code>C4</code> 源码分析的文章，
经过一番搜索，
发现其中最佳的一系列分析是<a href="https://github.com/lotabout/write-a-C-interpreter">https://github.com/lotabout/write-a-C-interpreter</a>，
它是国内的一个博主写的。</p>
<h2>伪自举</h2>
<p>虽说 C4 号称实现了自举，但感觉并不是真的自举，因为 C4 里面的打印函数是直接链接的最初编译器自带的 printf 代码，
自己并未真正实现这些。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E5%8D%AB%E7%94%9F%E5%AE%9E%E7%8E%B0.html</id>
    <title>编程语言宏之卫生实现</title>
    <updated>2022-06-07T12:14:00+08:00</updated>
    <published>2022-06-07T12:14:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E5%8D%AB%E7%94%9F%E5%AE%9E%E7%8E%B0.html"/>
    <summary>前两篇博文引入和讲解了各种宏的用法，本文进一步讲解宏的各种分类及实现。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>前两篇博文引入和讲解了各种宏的用法，本文进一步讲解宏的各种分类及实现。</p>
<h2>宏的分类</h2>
<p>scheme 宏的概念之所以不易于理解，就在于各种概念混杂在一起了，
如果我们从各种角度分开看，应该会更于理解。</p>
<p>如果我们从宏是否是卫生或者不卫生角度看，宏可以被分为两类：卫生宏，不卫生宏。</p>
<p>如果我们从宏是否是高级或者低级的角度看，宏可以被分为两类：高级宏，低级宏。</p>
<p>如果我们从宏是否是声明式或者过程式的角度看，宏可以被分为两类：声明宏，过程宏。
这种分类与高级/低级分类雷同，不过用不同的名称更能说明含义。</p>
<p>如果我们从宏是否是词法标记(token)替换或者语法树替换的角度看，宏可以被分为两类：词法宏，语法宏。</p>
<p>下面是一些宏系统实现的分类：</p>
<table><thead><tr><th>宏实现</th><th>卫生/不卫生</th><th>高级/低级</th><th>声明/过程</th><th>词法/语法</th></tr></thead><tbody>
<tr><td>c macro</td><td>不卫生宏</td><td>低级宏</td><td>过程宏</td><td>词法宏</td></tr>
<tr><td>defmacro</td><td>不卫生宏</td><td>低级宏</td><td>过程宏</td><td>语法宏</td></tr>
<tr><td>syntax-rules</td><td>卫生宏</td><td>高级宏</td><td>声明宏</td><td>语法宏</td></tr>
<tr><td>syntatic-closure</td><td>卫生宏</td><td>低级宏</td><td>过程宏</td><td>语法宏</td></tr>
<tr><td>explicit-renaming</td><td>卫生宏</td><td>低级宏</td><td>过程宏</td><td>语法宏</td></tr>
<tr><td>syntax-case</td><td>卫生宏</td><td>低级&amp;高级宏</td><td>声明&amp;过程宏</td><td>语法宏</td></tr>
</tbody></table>
<p>其中 <code>syntatic-closure</code>、<code>explicit-renaming</code> 和 <code>syntax-case</code> 前面并未涉及，
这几个宏系统是 scheme 为了引入卫生宏而发明的各种算法底层实现，下文将有进一步讲解。</p>
<h2>宏系统的各种实现</h2>
<p>自 scheme 引入卫生宏的概念后，历史上出现了各种实现方式，下面是一个简单的时间线：</p>
<ul>
<li>1986: Kohlbecker - introduced the idea of hygiene, low-level, used an O(n2) coloring algorithm</li>
<li>1987: Kohlbecker - introduced declare-syntax, high-level, the precursor to syntax-rules</li>
<li>1988: Bawden &amp; Rees - &quot;Syntactic closures,&quot; low-level, faster than Kohlbecker's algorithm</li>
<li>1991: Clinger &amp; Rees - Explicit renaming, low-level, based on syntactic-closures but also supports syntax-rules</li>
<li>1992: Dybvig - Syntax-case, primary motivation to remove the distinction between low-level and high-level</li>
</ul>
<p>第一个，Kohlbecker 首次提出了宏的卫生的概念。因为这个算法低效，现今已经没有人用了。</p>
<p>第二个，作者还是 Kohlbecker，用模式匹配的方式来声明宏，这就是 syntax-rules 的前身。</p>
<p>第三个，syntax closure，引入语法闭包概念，下文重点介绍此概念。</p>
<p>第四个，explicit renaming，显式重命名，本质与 syntax closure 类似。</p>
<p>第五个，syntax-case，即支持低级/过程宏，也支持高级/声明宏，
在 r6rs 中定义，但是由于其实现非常复杂，引起了很大争议，
最终在 r7rs 中被去除，r7rs 只保留了 systax-rules 的声明宏定义，
因低级宏的实现各方都未能达成一致，很难标准化，所以在最新的 r7rs 标准定义中只定义了 syntax-rules 声明宏。</p>
<h2>syntax closure，语法闭包</h2>
<p>卫生宏的本质问题是：符号到底对应宏定义时期的环境，还是宏展开时期的环境。</p>
<p>由此 syntax closure 算法引入了两个环境变量，<code>usage-environment</code> 和 <code>macro-environment</code>，
分别对应宏展开时的环境和宏定义时的环境，
为了获取某个环境中某个符号所绑定的对象，又引入了 <code>make-syntactic-closure</code> 过程。</p>
<p>这样我们可以用 syntax closure 宏系统来实现卫生的 <code>swap</code> 宏：</p>
<pre><code>(define-syntax swap
  (lambda (form usage-environment macro-environment)
    (let ((a (make-syntactic-closure usage-environment '() (cadr form)))
          (b (make-syntactic-closure usage-environment '() (caddr form)))
          (let (make-syntactic-closure macro-environment '() 'let))
          (tmp (make-syntactic-closure macro-environment '() 'tmp))
          (set! (make-syntactic-closure macro-environment '() 'set!)))
      `(,let ((,tmp ,a))
        (,set! ,a ,b)
        (,set! ,b ,tmp)))))
</code></pre>
<p>其中的 <code>form</code> 就是我们使用 <code>swap</code> 宏的形式，
比如 <code>(swap x y)</code> 宏调用形式，
这样，展开时上面的 <code>(car form)</code> 返回的是 <code>swap</code> 符号，
<code>(cadr form)</code> 返回的是 <code>x</code> 符号，
<code>（caddr form)</code> 返回的是 <code>y</code> 符号。</p>
<p><code>make-syntactic-closure</code> 的调用方法是：</p>
<pre><code>(make-syntactic-closure env free-variables form)
</code></pre>
<p>返回的对象与 <code>form</code> 等同，
只是转换 <code>form</code> 使用 <code>env</code> 环境内的符号绑定，
而 <code>free-variables</code> 列表是 <code>form</code> 内被排除不被解释的符号列表，
这为了在宏的使用中，可以使用一些特殊的符号作为某些标记，
比如 <code>loop</code> 循环中的 <code>break</code>、<code>continue</code> 标记。</p>
<p>上面定义 swap 的方法显式的定义了 <code>a</code>, <code>b</code> 符号引用的是 <code>usage-environment</code> 环境的绑定，宏展开时的环境，
而 <code>let</code>、<code>tmp</code>、<code>set!</code> 符号引用的是 <code>macro-environment</code> 环境的绑定，宏定义时的环境。</p>
<p>为了简化上面的写法，
在定义宏时可以让符号默认使用宏定义时的环境或者默认使用宏展开时的环境，
由此出现了两种 syntax 的变种：</p>
<ul>
<li>sc-macro-transformer，默认使用宏定义时的环境</li>
<li>rsc-macro-transformer，默认使用宏展开时的环境</li>
</ul>
<pre><code>(define sc-macro-transformer
  (lambda (f)
    (lambda (form usage-environment macro-environment)
      (make-syntactic-closure macro-environment '() (f form usage-environment)))))

(define rsc-macro-transformer
  (lambda (f)
    (lambda (form usage-environment macro-environment)
      (f form macro-environment))))
</code></pre>
<h4>sc-macro-transformer</h4>
<p>其中 <code>sc</code> 是 <code>syntax closure</code> 的缩写，
<code>sc-macro-transformer</code> 定义宏的符号默认使用宏定义时环境的绑定，
所以只需要接受宏展开时的环境变量 <code>usage-environment</code> 参数了，</p>
<p>下面是用 <code>sc-macro-transformer</code> 定义 <code>swap</code> 宏的方法：</p>
<pre><code>(define-syntax swap
  (sc-macro-transformer
    (lambda (form usage-environment)
      (let ((a (make-syntactic-closure usage-environment '() (cadr form)))
            (b (make-syntactic-closure usage-environment '() (caddr form))))
        `(let ((tmp ,a))
          (set! ,a ,b)
          (set! ,b tmp))))))
</code></pre>
<h4>rsc-macro-transformer</h4>
<p>其中 <code>rsc</code> 是 <code>reverse syntax closure</code> 的缩写，
<code>rsc-macro-transformer</code> 定义宏的符号默认使用宏展开时环境的绑定，
所以只需要接受宏定义时的环境变量 <code>macro-environment</code> 参数了，</p>
<p>下面是用 <code>rsc-macro-transformer</code> 定义 <code>swap</code> 宏的方法：</p>
<pre><code>(define-syntax swap
  (rsc-macro-transformer
    (lambda (form macro-environment)
      (let ((a (cadr form))
            (b (caddr form))
            (let (make-syntactic-closure macro-environment '() 'let))
            (tmp (make-syntactic-closure macro-environment '() 'tmp))
            (set! (make-syntactic-closure macro-environment '() 'set!)))
        `(,let ((,tmp ,a))
          (,set! ,a ,b)
          (,set! ,b ,tmp))))))
</code></pre>
<p><code>rsc-macro-transformer</code> 可以用类似于 lisp 中的 <code>defmacro</code> 的方法定义 <code>swap</code> 宏：</p>
<pre><code>  (define-syntax swap!
    (rsc-macro-transformer
     (lambda (form env)
       (let ((a (cadr form))
             (b (caddr form))
             (tmp (gensym)))
         `(let ((,tmp ,a))
            (set! ,a ,b)
            (set! ,b ,value))))))
</code></pre>
<p>上面的宏与 lisp 中的用 <code>defmacro</code> 定义 <code>swap</code> 宏的方法等效。</p>
<h2>er-macro-transformer</h2>
<p><code>er-macro-transformer</code> 是后来又发明的另外一种宏系统，
不再显式传递 <code>usage-environment</code> 和 <code>macro-environment</code> 参数，
而是传递 <code>rename</code> 参数用来重命名符号，和一个 <code>compare</code> 参数用来比较两个符号是否相同。</p>
<p>其中 <code>er</code> 是 <code>explicit renaming</code> 的缩写，显示重命名。</p>
<p>下面是用 <code>syntax closure</code> 实现 <code>er-macro-transformer</code> 的方法：</p>
<pre><code>(define er-macro-transformer
  (lambda (f)
    (lambda (form usage-environment macro-environment)
      (let ((rename
              (let ((renames '()))
                (lambda (identifier)
                  (let ((cell (assq identifier renames)))
                    (if cell
                        (cdr cell)
                        (let ((name (make-syntactic-closure macro-environment '() identifier)))
                          (set! renames (cons (cons identifier name) renames))
                          name))))))
            (compare
              (lambda (x y) (identifier=? usage-environment x usage-environment y))))
        (f form rename compare))))))
</code></pre>
<p>下面是用 <code>er-macro-transformer</code> 定义 <code>swap</code> 的方法：</p>
<pre><code>  (define-syntax swap!
    (er-macro-transformer
      (lambda (form rename compare)
        (let ((a (cadr form))
              (b (caddr form)))
          `(,(rename 'let) ((,(rename 'tmp) ,a))
             (,(rename 'set!) ,a ,b)
             (,(rename 'set!) ,b ,(rename 'tmp)))))))
</code></pre>
<h2>syntax-case</h2>
<p><code>syntax-case</code> 是一种兼有低级/高级特性的宏系统，被 r6rs 引入，后因其复杂的实现又被 r7rs 去除了。</p>
<p>下面我们分别用低级特性和高级特性来分别写 <code>swap</code> 宏对应的实现方式。</p>
<h4>syntax-case 高级方式</h4>
<pre><code>(define-syntax swap!
  (lambda (stx)
    (syntax-case stx ()
      ((swap! a b)
       (syntax
         (let ((tmp a))
           (set! a b)
           (set! b tmp)))))))
</code></pre>
<p>这种高级方式已经非常类似于 <code>syntax-rules</code> 了，
这里的 <code>stx</code> 是一个 <code>syntax</code> 语法对象，
<code>syntax-case</code> 首先通过 <code>(swap! a b)</code> 解析匹配它，
这里有点声明式的含义，
而后面的 <code>syntax</code> 语句与 <code>syntax-rules</code> 并不同，
不是模板，而是一个正常执行的语句，
这里有点过程式的含义。</p>
<p>如果匹配到，将相关的语法对象绑定到 <code>a</code> 和 <code>b</code> 符号，
然后返回后面的 <code>syntax</code> 对象，
否则报错，
这里的 <code>syntax</code> 语句就是把各种语法对象重新再进行组装起来。</p>
<h4>syntax-case 低级方式</h4>
<p><code>syntax-case</code> 可以对 <code>sexp</code> 的执行各种计算，只要保证最后再转换成 <code>syntax</code> 对象就可以了。</p>
<pre><code>  (define-syntax swap
    (lambda (stx)
      (syntax-case stx ()
        ((swap! a b)
         (let ((a (syntax-object-&gt;datum (syntax a)))
               (b (syntax-object-&gt;datum (syntax b))))
           (datum-&gt;syntax-object
             (syntax swap!)
             `(let ((tmp ,a))
                (set! ,a ,b)
                (set! ,b tmp))))))))
</code></pre>
<h2>总结</h2>
<p>从使用角度看，<code>syntax-rules</code> 无疑是最简单的，基本没有心智负担，
但是 <code>syntax-rules</code> 并不是太自由，
不能像 <code>defmacro</code> 那样自由的对 <code>sexp</code> 进行计算。</p>
<p>从实现角度看，<code>syntax closure</code> 语法闭包是最易实现的，但是使用上没有 <code>syntax-rules</code> 简单。</p>
<p><code>syntax-rules</code>是一种高级宏系统，大多 scheme 都是通过低级宏来实现它的。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E8%BF%9B%E9%98%B6.html</id>
    <title>编程语言宏之进阶</title>
    <updated>2022-06-06T11:45:00+08:00</updated>
    <published>2022-06-06T11:45:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E8%BF%9B%E9%98%B6.html"/>
    <summary>所有编程语言的语法设计都有终止的一天， 有了宏系统，语言设计人员可以不停的通过宏系统扩展新语法， 使得编程语言永葆青春，不受语言语法限制。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>所有编程语言的语法设计都有终止的一天，
有了宏系统，语言设计人员可以不停的通过宏系统扩展新语法，
使得编程语言永葆青春，不受语言语法限制。</p>
<p>世事皆有两面性，得失之间相互依存。
宏系统可以极大减少单调冗繁的代码，构造出强大的领域特定语言（DSL, Domain Specific Language）,
但是宏的展开比函数调用更难于调试，使用宏需要极其细心，同时也使代码更难于理解。</p>
<p>正是由于上述原因，上世纪八九十年代及世纪之交，
新出现的编程语言都极力避免使用宏系统，
大多利用语言自省功能来进行元编程，
但最近几年，有些静态语言（rust、crystal、julia、...）又开始引入了宏的高级功能。</p>
<p>上篇博客中我们了解到 C 语言宏只是词法 token 级别的简单替换，
接下来我们通过 lisp 语言和 scheme 来讲解较高级的宏系统，
语法级别的用户自定义替换。</p>
<p>理解本文需要你事先熟悉 lisp 语法，以及 sexp 表达式。</p>
<h2>lisp 中的宏</h2>
<p>lisp 语言有 <code>if</code> 条件基本控制语句，而 <code>unless</code> 条件控制结构就是一个宏，
下面看看 lisp 中如何定义一个 <code>unless</code> 宏：</p>
<pre><code>(defmacro unless (condition body)
  (list 'if ('not condition) body))
</code></pre>
<p>lisp 为了简化 macro 的定义，引入了 <code>quasiquote</code>、<code>unquote</code>、<code>unquote-splicing</code> 简写形式，
下面是用 <code>quasiquote</code> 来定义同样的 <code>unless</code> 宏的方法：</p>
<pre><code>(defmacro unless (condition body)
  `(if (not ,condition) ,body))
</code></pre>
<p>上面两种写法都是定义（defmacro, define macro）一个叫 <code>unless</code> 的宏，
这样，代码中如果遇到 <code>(unless some-condition body)</code> 形式，
都会先将该形式的语法转换成 <code>(if (not some-condition) body)</code> 的形式，
然后由 lisp 解释执行。</p>
<p>上面我们可以看到，lisp 定义宏，类似于定义一个函数，
只是这个函数的参数是宏的语法输入，而函数返回的值就是宏的展开，
而又因为 lisp 的代码和数据具有同构性（这也是 sexp 表达式强大之处），
使得宏的展开定义过程极其容易，这也是 lisp 中宏得到普及的一个原因。</p>
<h2>不卫生宏</h2>
<p>虽然 lisp 中定义宏极其方便简单，
但是使用它却要极其小心，因为它有些缺点，就是<code>不卫生</code>，
也就是说 lisp 中宏的展开极易受到运行时上下文环境的影响，
产生意向不到的结果，以至于报错。</p>
<p>比如来看下面 <code>swap</code> 宏的定义：</p>
<pre><code>(defmacro swap (a, b)
  `(let ((tmp ,a))
    (set! ,a ,b)
    (set! ,b tmp)))
</code></pre>
<p>使用上面的宏，我们会碰到两种类型的错误：</p>
<ol>
<li>宏定义引入了重名的符号绑定问题</li>
<li>宏定义使用了运行环境中被重新绑定的符号引用问题</li>
</ol>
<h4>宏定义引入了重名的符号绑定问题</h4>
<p>使用 swap 宏时，如果其参数与 swap 定义时引入的 <code>tmp</code> 变量重名，
就会导致相关变量作用域被改变的问题：</p>
<pre><code>(define tmp 1)
(define  y 2)
(swap tmp y)
</code></pre>
<p>上面的 <code>(swap tmp y)</code> 在宏展开后就成了：</p>
<pre><code>(let ((tmp tmp))
  (set! tmp y)
  (set! y tmp))
</code></pre>
<p>这样就会使宏不能达到预期效果。</p>
<h4>宏定义使用了运行环境中被重新绑定的符号引用问题</h4>
<p>我们在定义宏时用了 <code>set!</code> 绑定，
如果我们在使用宏时，重新绑定了 <code>set!</code> 符号，也会使宏不能达到预期效果，
如下：</p>
<pre><code>(define x 1)
(define y 2)
(let ((set! display))
  (swap x y)
</code></pre>
<h4>如何使用 lisp 宏</h4>
<p>为了解决上面第 1 个问题，lisp 中引入了 <code>gensym</code> 函数，调用它会生成一个独一无二的符号，
这样就可以保证绝对不会出现重名问题：</p>
<pre><code>(defmacro swap (a, b)
  (let ((tmp (gensym))
    `(let ((,tmp ,a))
      (set! ,a ,b)
      (set! ,b ,tmp)))))

</code></pre>
<p>这样在展开 <code>(swap tmp y)</code> 时，就会展开成：</p>
<pre><code>(let ((&lt;tmp-uniq-symbol&gt; tmp))
  (set! tmp y)
  (set! y &lt;tmp-uniq-symbol&gt;))
</code></pre>
<p>但是，lisp 中对于第2种问题却没有什么较好的解决办法，
只能让程序员小心定义和使用宏，避免出现这种问题。</p>
<h2>scheme 中的卫生宏</h2>
<p>为了彻底解决 lisp 上面出现的两种问题，lisp 语言的一个分支 scheme 引入了<code>卫生宏</code>的概念。</p>
<p>用 scheme 中宏定义的方法来定义 swap 宏如下：</p>
<pre><code>(define-syntax swap
  (syntax-rules ()
    ((swap a b) (let ((tmp a))
                  (set! a b)
                  (set! b tmp)))))
</code></pre>
<p>scheme 中的 <code>syntax-rules</code> 中尽管引入了 tmp 和 set! 符号，
但是 scheme 实现却保证了：</p>
<ul>
<li><code>tmp</code> 在宏扩展时会被重命名，保证唯一性</li>
<li><code>set!</code> 在宏扩展时绑定的对象是宏定义时环境中的 <code>set!</code> 对象</li>
</ul>
<p>这样通过引入 <code>syntax-rules</code> 宏定义，scheme 语言彻底解决了不卫生宏的问题。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E6%A6%82%E5%BF%B5.html</id>
    <title>编程语言宏之概念</title>
    <updated>2022-06-02T15:02:00+08:00</updated>
    <published>2022-06-02T15:02:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%8F%E4%B9%8B%E6%A6%82%E5%BF%B5.html"/>
    <summary>很多人不理解宏的概念，其实这与翻译有很大关系， 如果将 `macro` 理解为 `缩写`，就更易懂了，翻译成`缩变`就更合适了。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>很多人不理解宏的概念，其实这与翻译有很大关系，
如果将 <code>macro</code> 理解为 <code>缩写</code>，就更易懂了，翻译成<code>缩变</code>就更合适了。</p>
<p>自然语言中，<code>缩写</code>是简单的替换，
<code>人大</code>就是<code>人民代表大会</code>，
<code>中共</code>就是<code>中国共产党</code>，
<code>GDP</code>就是<code>Gross Domestic Product</code>，翻译过来就是<code>国内生产总值</code>,
编程语言中也存在类似的概念，这就是我们说的<code>宏</code>。</p>
<h2>什么是宏？</h2>
<p>在编程语言中，<code>macro</code>(macro instruction 的简称) 是将某些输入替换成某些输出的规则，
它的输入、输出类型可以是字符、词法 token 或者语法树。</p>
<p>宏可以携带参数，一个或者多个，根据参数的不同，替换为不同的内容，也就是<code>可编程替换</code>。</p>
<p>编程语言中涉及宏的地方有两种：</p>
<ul>
<li>宏的定义：用来定义替换规则</li>
<li>宏的展开：用宏的替换规则将宏的输入展开成宏的输出</li>
</ul>
<h2>宏示例</h2>
<p>许多编程语言有宏的概念，比如 C，TeX，m4，lisp，scheme，julia，scala，rust，以及某些汇编语言等等，
下面我们用 C 语言中的宏来示例宏定义和用法。</p>
<p>比如在 C 语言中定义一个简单的 <code>max</code> 宏如下：</p>
<pre><code>#define max(a,b) ((a) &gt;= (b) ? (a) : (b))
</code></pre>
<p>这里定义了一个名为 <code>max</code> 的宏，
这个宏有两个参数是 <code>a</code> 和 <code>b</code>，
而后面的 <code>((a) &gt;= (b) ? (a) : (b))</code> 用来规定替换 <code>max(a, b)</code> 形式的输出样式。</p>
<p>当在代码中使用 <code>max</code> 宏的时候，根据参数的不同进行替换相应的代码，
比如下面的代码：</p>
<pre><code>i + max(x*y, u-v) + j
</code></pre>
<p>这里 <code>max(x*y, u-v)</code> 就相当于一个编程语言 <code>缩写</code>，
其中 <code>x*y</code> 会匹配到 max 定义中的 <code>a</code> 参数，而 <code>u-v</code> 就匹配到 max 定义中的 <code>b</code> 参数，</p>
<pre><code>max(x*y, u-v)
     |    |
     |    |
     v    v
max( a ,  b )
</code></pre>
<p>然后根据 max 定义，将 <code>max(a, b)</code> 形式的宏调用进行参数替换：</p>
<pre><code>(( a ) &gt;= ( b ) ? ( a ) : ( b ))
   |        |       |       |
   |        |       |       |
   v        v       v       v
((x*y) &gt;= (u-v) ? (x*y) : (u-v))
</code></pre>
<p>整个 <code>i + max(x*y, u-v) + j</code> 最终替换后的结果是：</p>
<pre><code>i + ((x*y) &gt;= (u-v) ? (x*y) : (u-v)) + j
</code></pre>
<h2>更复杂的宏</h2>
<p>当然，C 语言中的宏还是比较简单的，它仅仅是词法 token 级别的替换，
有些编程语言有更复杂，更具有编程性的宏，
它们中的代表是 lisp 语言，lisp 可以说是对宏应用最彻底的一个语言，
这与 lisp 的语法是 sexp(S-expressions, Symbolic EXPression)有关，
具体需要看下一篇博文了。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/compiler/minilisp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <title>minilisp源码阅读</title>
    <updated>2022-05-29T20:53:00+08:00</updated>
    <published>2022-05-29T20:53:00+08:00</published>
    <link href="https://fugangqiang.github.io/posts/compiler/minilisp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <summary>## minilisp 简介...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <h2>minilisp 简介</h2>
<p>minilisp 是一个简单的 lisp 解释器，由 <a href="https://github.com/rui314">Rui Ueyama</a> 实现，
大约 1000 行 C 语言代码，注释很详细，再抛去空行，仅仅 700 多行, 
代码极为精简，REPL(Read-Eval-Print-Loop) 的执行过程也极为清晰简单，
阅读 minilisp 源码，再次惊叹于 lisp 的<code>简单</code>哲学。</p>
<p>minilisp 源码地址：<a href="https://github.com/rui314/minilisp">https://github.com/rui314/minilisp</a></p>
<p>minilisp 实现的功能有：</p>
<ul>
<li>支持基本类型有空值、整数(integer)、符号(symbol)、序对(cons cells)</li>
<li>词法(lexical)作用域</li>
<li>闭包(closure)</li>
<li>if 条件表达式</li>
<li>while 循环表达式</li>
<li>基本函数有：+, -, &lt;, =, eq, println, gensym, macroexpand</li>
<li>函数</li>
<li>宏</li>
<li>复制(copying)算法垃圾收集系统</li>
</ul>
<h2>垃圾收集系统</h2>
<p>minilisp 垃圾收集系统是复制算法类型，其算法由 cheney 1970 年研究提出，
不同于深度优先遍历复制算法，其扫描复制时采用广度优先遍历。</p>
<p>垃圾收集的 root 也极其巧妙，除了全局变量 <code>Symbols</code> 这个符号列表外，
其他的 root 变量全部来自于运行时的函数栈中的临时变量，
更巧妙的是，这些变量可以通过一个单向链表在函数调用栈间进行索引遍历，
这个单向链表的构造是通过下面的 <code>DEFINEx</code> 宏进行生成的：</p>
<pre><code>#define ROOT_END ((void *)-1)

#define ADD_ROOT(size)                          \
    void *root_ADD_ROOT_[size + 2];             \
    root_ADD_ROOT_[0] = root;                   \
    for (int i = 1; i &lt;= size; i++)             \
        root_ADD_ROOT_[i] = NULL;               \
    root_ADD_ROOT_[size + 1] = ROOT_END;        \
    root = root_ADD_ROOT_

#define DEFINE1(var1)                           \
    ADD_ROOT(1);                                \
    Obj **var1 = (Obj **)(root_ADD_ROOT_ + 1)

#define DEFINE2(var1, var2)                     \
    ADD_ROOT(2);                                \
    Obj **var1 = (Obj **)(root_ADD_ROOT_ + 1);  \
    Obj **var2 = (Obj **)(root_ADD_ROOT_ + 2)
</code></pre>
<h2>宏和函数</h2>
<p>minilisp 实现代码中最精彩的地方应该是宏和函数的实现竟然是统一的，
这个应该在其他的 lisp 实现中也类似吧。</p>
<p>宏对象、函数对象表示完全一样，唯一不同的是类型标签(type)：</p>
<pre><code>static Obj *make_function(void *root, Obj **env, int type, Obj **params, Obj **body) {
    assert(type == TFUNCTION || type == TMACRO);
    Obj *r = alloc(root, type, sizeof(Obj *) * 3);
    r-&gt;params = *params;
    r-&gt;body = *body;
    r-&gt;env = *env;
    return r;
}
</code></pre>
<p>宏与函数的调用共用了 <code>apply_func</code> 实现，不同的是，宏的参数不会提前被计算，宏调用返回的列表会再次被 eval 计算，</p>
<pre><code>static Obj *macroexpand(void *root, Obj **env, Obj **obj) {
    if ((*obj)-&gt;type != TCELL || (*obj)-&gt;car-&gt;type != TSYMBOL)
        return *obj;
    DEFINE3(bind, macro, args);
    *bind = find(env, (*obj)-&gt;car);
    if (!*bind || (*bind)-&gt;cdr-&gt;type != TMACRO)
        return *obj;
    *macro = (*bind)-&gt;cdr;
    *args = (*obj)-&gt;cdr;
    return apply_func(root, env, macro, args);
}

static Obj *apply(void *root, Obj **env, Obj **fn, Obj **args) {
    if (!is_list(*args))
        error(&quot;argument must be a list&quot;);
    if ((*fn)-&gt;type == TPRIMITIVE)
        return (*fn)-&gt;fn(root, env, args);
    if ((*fn)-&gt;type == TFUNCTION) {
        DEFINE1(eargs);
        *eargs = eval_list(root, env, args);
        return apply_func(root, env, fn, eargs);
    }
    error(&quot;not supported&quot;);
}
</code></pre>
<p>更让人意向不到的是，宏和函数调用都是通过 <code>env</code> 实现了词法作用域。</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/gentoo/Gentoo%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html</id>
    <title>Gentoo 系统安装</title>
    <updated>2021-11-01T19:11:23+08:00</updated>
    <published>2021-11-01T19:11:23+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/gentoo/Gentoo%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <summary>前天开始在家用笔记本上安装 Gentoo Linux 系统， 并没有想像的复杂，步骤得当，很容易安装成功， 现将安装经历总结如下：...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>前天开始在家用笔记本上安装 Gentoo Linux 系统，
并没有想像的复杂，步骤得当，很容易安装成功，
现将安装经历总结如下：</p>
<h2>安装前注意事项</h2>
<ul>
<li>本文安装方法不适用于虚拟机安装，虚拟机安装需要配置不同的内核参数，应该还有其他注意事项。</li>
<li>如果是新手，需提前阅读、理解官方 Handbook 安装步骤，与网上一些同学安装方法进行比对更佳。</li>
<li>如果不熟悉内核配置，建议用 <code>genkernel</code> 工具来编译、安装内核。</li>
<li>安装前，建议先阅读一下 portage 的使用及原理，使用 portage 相关命令遇到报错时会很有用。</li>
<li>在安装过程中，如果安装失败，可以通过启动 U 盘，重新 chroot 进去，修复系统</li>
</ul>
<p>gentoo 安装文档参考：</p>
<ul>
<li><a href="https://wiki.gentoo.org/wiki/Handbook:Main_Page">Handbook</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Quick_Installation_Checklist">Quick Installation Checklist</a></li>
</ul>
<h2>搭建环境</h2>
<ul>
<li>amd64 架构</li>
<li>gpt 分区</li>
<li>gentoo</li>
<li>systemd-boot 引导加载</li>
<li>systemd 初始化进程</li>
</ul>
<h2>安装基本步骤</h2>
<ul>
<li>制作 Linux 启动 U 盘</li>
<li>BIOS 启动选项设置</li>
<li>安装准备</li>
<li>磁盘分区、格式化</li>
<li>下载、解压 Gentoo Stage3 压缩文件</li>
<li>配置修改</li>
<li>chroot</li>
<li>更新系统</li>
<li>编译 Linux 内核</li>
<li>建立 fstab 文件</li>
<li>配置系统</li>
<li>安装引导程序</li>
<li>重启</li>
<li>安装桌面系统</li>
<li>清理系统</li>
</ul>
<h2>制作 Linux 启动 U 盘</h2>
<p>不建议用 Gentoo 官方提供的启动盘镜像，
因为安装系统时，需要手动输入许多命令，
这些命令可以通过网页文档轻松复制得到，
使用有图形化可引导的 Linux 启动 U 盘，
可以节省很多时间，
考察一番后，选择了 manjaro-xfce iso 镜像文件来制作启动盘，
下载网址为 <a href="https://manjaro.org/download/">https://manjaro.org/download/</a>。</p>
<p>下载完毕后，校验下载镜像文件是否有误：</p>
<pre><code>sha1sum manjaro-xfce-21.1.4-210927-linux513.iso
</code></pre>
<p>检测 hash 字符串，确保与官方网站一致。</p>
<p>dd 命令制作 USB 启动盘：</p>
<pre><code>dd if=./manjaro-xfce-21.1.4-210927-linux513.iso of=/dev/sdc bs=4M status=progress oflag=sync
</code></pre>
<p><code>dd</code> 命令是 Linux 平台下的，如果需要在 Windows 下制作启动盘需使用 <code>Rufus</code> 工具。</p>
<h2>BIOS 启动选项设置</h2>
<p>将 U 盘插入笔记本，开机，当刚出现开机画面时，按 <code>F2</code>进入 BIOS 系统，这里有些系统有可能是其他键。</p>
<p>将 Boot Mode 设为 UEFI Mode，关闭 Secure Boot。</p>
<p>调整优先从 U 盘启动。</p>
<p>保存设置并退出。</p>
<p>进入开机画面，此时显示的就是启动 U 盘系统的加载画面。</p>
<h2>安装准备</h2>
<p>进入 U 盘的 Manjaro Linux 系统后，打开终端和浏览器，
如果使用 WiFi 联网，需要选择设置 WiFi 网络。</p>
<p>在浏览器中可以打开 Gentoo Handbook， 一边看文档，一边复制命令在终端执行。</p>
<p>在终端中切换到 root 用户环境：</p>
<pre><code>su
</code></pre>
<h2>磁盘分区、格式化</h2>
<p>我笔记本里面只有一个 238GiB 固态硬盘，分区方案如下：</p>
<table><thead><tr><th>分区</th><th>挂载路径</th><th>类型</th><th>大小</th></tr></thead><tbody>
<tr><td>boot 分区</td><td>/boot</td><td>fat32</td><td>512MiB</td></tr>
<tr><td>swap 分区</td><td>linux swap</td><td>swap</td><td>4GiB</td></tr>
<tr><td>root 分区</td><td>/</td><td>ext4</td><td>100GiB</td></tr>
<tr><td>home 分区</td><td>/home</td><td>ext4</td><td>100GiB</td></tr>
<tr><td>backup 分区</td><td>不挂载，备用</td><td>ext4</td><td>34GiB</td></tr>
</tbody></table>
<p>注意这里单位是 GiB，而不是 GB。</p>
<h3>查看分区列表</h3>
<p>磁盘分区官方文档用的是 <code>fdisk</code>，本文用的是 <code>parted</code> 命令。</p>
<p>列出系统所有磁盘分区情况：</p>
<pre><code>parted -l
</code></pre>
<p>我这里列出两个磁盘：</p>
<ul>
<li>/dev/sda       30GiB       // USB 启动盘</li>
<li>/dev/nvme0n1   256GiB      // 笔记本固态硬盘</li>
</ul>
<p>注意这里列表里面的单位是 GB，而不是 GiB。</p>
<h3>进入分区命令</h3>
<p>准备将 gentoo 系统安装在笔记本的固态硬盘上面，所以对 <code>/dev/nvme0n1</code> 磁盘进行分区：</p>
<pre><code>parted /dev/nvme0n1
</code></pre>
<p>进入 parted 命令模式，下面所有磁盘分区操作都是在 parted 命令模式下输入。</p>
<h3>修改成 GPT 分区表</h3>
<pre><code>(parted) mklabel GPT
</code></pre>
<p>出现警告「硬盘数据将会全部丢失」，回答 Yes</p>
<h3>创建分区</h3>
<pre><code>(parted) mkpart boot fat32 1MiB 512MiB
(parted) mkpart swap linux-swap 512MiB 4GiB
(parted) mkpart root ext4 4GiB 104GiB
(parted) mkpart home ext4 104GiB 204GiB
(parted) mkpart backup ext4 204GiB 100%
(parted) set 1 esp on
(parted) quit
</code></pre>
<p>注意这里单位是 GiB，而不是 GB。</p>
<h3>格式化分区</h3>
<pre><code>mkfs.fat -F 32 /dev/nvme0n1p1
mkswap /dev/nvme0n1p2
mkfs.ext4 /dev/nvme0n1p3
mkfs.ext4 /dev/nvme0n1p4
mkfs.ext4 /dev/nvme0n1p5
</code></pre>
<h2>下载、解压 Gentoo Stage3 压缩文件</h2>
<h3>挂载主分区</h3>
<pre><code>swapon /dev/nvme0n1p2
mkdir -p /mnt/gentoo
mount /dev/nvme0n1p3 /mnt/gentoo
</code></pre>
<h3>下载 Gentoo Stage3 压缩文件</h3>
<p>可以直接从官网下载，为了加快下载速度，我是用的清华源：</p>
<pre><code>cd /mnt/gentoo
wget https://www.mirrorservice.org/sites/distfiles.gentoo.org//releases/amd64/autobuilds/20211024T170536Z/stage3-amd64-systemd-20211024T170536Z.tar.xz
</code></pre>
<p>验证下载的 gentoo stage3 包：</p>
<pre><code>sha512sum stage3-amd64-systemd-20211024T170536Z.tar.xz
# 相对应 hash 地址：https://mirror.isoc.org.il/pub/gentoo/releases/amd64/autobuilds/20211024T170536Z/stage3-amd64-systemd-20211024T170536Z.tar.xz.DIGESTS
# 检测 hash 是否与官网提供的一致
</code></pre>
<h3>解压 Gentoo Stage3 压缩文件</h3>
<p>检测如果一致，说明下载正确，可以进行解压操作：</p>
<pre><code>tar xpvf stage3-amd64-systemd-20211024T170536Z.tar.xz --xattrs-include='*.*' --numeric-owner
</code></pre>
<h2>配置修改</h2>
<h3>修改 <code>portage/make.conf</code> 文件</h3>
<pre><code>nano -w /mnt/gentoo/etc/portage/make.conf
</code></pre>
<p>修改内容如下：</p>
<pre><code>COMMON_FLAGS=&quot;-march=native -O2 -pipe&quot;
CFLAGS=&quot;${COMMON_FLAGS}&quot;
CXXFLAGS=&quot;${COMMON_FLAGS}&quot;

DISTDIR=&quot;/var/cache/distfiles&quot;
PKGDIR=&quot;/var/cache/binpkgs&quot;

MAKEOPTS=&quot;-j8&quot;
ACCEPT_LICENSE=&quot;*&quot;
GENTOO_MIRRORS=&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo&quot;
</code></pre>
<p>其中：</p>
<ul>
<li><code>MAKEOPTS</code> 里面的数字与 CPU 核数对应，加快编译速度，</li>
<li><code>GENTOO_MIRRORS</code> 使用的清华源，加快下载速度</li>
</ul>
<h3>修改 <code>portage/repos.conf</code> 文件</h3>
<pre><code>mkdir --parents /mnt/gentoo/etc/portage/repos.conf
cp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf
nano -w /mnt/gentoo/etc/portage/repos.conf/gentoo.conf
</code></pre>
<p>修改内容如下：</p>
<pre><code>[DEFAULT]
main-repo = gentoo

[gentoo]
location = /var/db/repos/gentoo
sync-type = rsync
sync-uri = rsync://rsync.gentoo.org/gentoo-portage
auto-sync = yes
sync-rsync-verify-jobs = 1
sync-rsync-verify-metamanifest = yes
sync-rsync-verify-max-age = 24
sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc
sync-openpgp-key-refresh-retry-count = 40
sync-openpgp-key-refresh-retry-overall-timeout = 1200
sync-openpgp-key-refresh-retry-delay-exp-base = 2
sync-openpgp-key-refresh-retry-delay-max = 60
sync-openpgp-key-refresh-retry-delay-mult = 4
</code></pre>
<h3>修改 <code>resolv.conf</code> 文件</h3>
<pre><code>cp --dereference /etc/resolv.conf /mnt/gentoo/etc/
</code></pre>
<h2>chroot</h2>
<pre><code>mount --types proc /proc /mnt/gentoo/proc
mount --rbind /sys /mnt/gentoo/sys
mount --make-rslave /mnt/gentoo/sys
mount --rbind /dev /mnt/gentoo/dev
mount --make-rslave /mnt/gentoo/dev
mount --bind /run /mnt/gentoo/run
mount --make-slave /mnt/gentoo/run
chroot /mnt/gentoo /bin/bash
source /etc/profile
export PS1=&quot;(chroot) ${PS1}&quot;
</code></pre>
<p>挂载 boot 分区：</p>
<pre><code>mount /dev/nvme0n1p1 /boot
</code></pre>
<h2>更新系统</h2>
<h3>同步 ebuild 库</h3>
<pre><code>emerge-webrsync
emerge --sync
</code></pre>
<h3>选择系统 profile</h3>
<pre><code>eselect profile list
eselect profile set NUMBER
</code></pre>
<p>这里根据自己的需要，选择了 systemd 的那个 profile</p>
<h3>systemd-boot 预设置</h3>
<pre><code>echo &quot;sys-apps/systemd gnuefi&quot; &gt;&gt; /etc/portage/package.use/systemdboot
</code></pre>
<h3>升级系统</h3>
<pre><code>emerge -a --update --deep --newuse @world
</code></pre>
<h2>编译 Linux 内核</h2>
<pre><code>emerge --ask sys-kernel/linux-firmware
emerge --ask sys-kernel/gentoo-sources
eselect kernel list
eselect kernel set NUMBER
</code></pre>
<ul>
<li>这里的 <code>NUMBER</code> 为选择的内核编号</li>
</ul>
<h3>手动编译安装</h3>
<pre><code>cd /usr/src/linux
make menuconfig
make -j5 &amp;&amp; make modules_install &amp;&amp; make install

# 安装 initramfs
emerge --ask sys-kernel/genkernel
genkernel --install --kernel-config=/path/to/used/kernel.config initramfs
</code></pre>
<h3>工具辅助编译安装</h3>
<p>建议新手用 <code>genkernel</code> 进行编译、安装内核：</p>
<pre><code>genkernel --install --kernel-config=/path/to/used/kernel.config all
</code></pre>
<p>查看生成的内核文件和 initramfs:</p>
<pre><code>ls /boot/vmlinuz* /boot/initramfs*
</code></pre>
<h2>建立 fstab 文件</h2>
<p>查看各分区的 UUID 和 PARTUUID:</p>
<pre><code>blkid
</code></pre>
<p>创建 fstab 文件：</p>
<pre><code>nano -w /etc/fstab
</code></pre>
<p>根据磁盘分区情况设置文件内容如下：</p>
<pre><code>UUID=XXX-XXX    /          ext4       rw,relatime	0 1
UUID=XXX-XXX    /boot      vfat       defaults     0 0
UUID=XXX-XXX    none       swap       sw           0 0
UUID=XXX-XXX    /home      ext4       defaults     0 2
</code></pre>
<h2>配置系统</h2>
<h3>用户配置</h3>
<pre><code>passwd   root
useradd -m -G wheel fu
passwd  fu
</code></pre>
<h3>语言本地化配置</h3>
<pre><code>echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.GB18030 GB18030&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN.GBK GBK&quot; &gt;&gt; /etc/locale.gen
echo &quot;zh_CN GB2312&quot; &gt;&gt; /etc/locale.gen
locale-gen
localectl set-locale en_US.utf8
</code></pre>
<h3>时区配置</h3>
<pre><code>timedatectl set-timezone Asia/Shanghai
</code></pre>
<h3>主机名配置</h3>
<pre><code>hostnamectl set-hostname Gentoo
</code></pre>
<h3>网络配置</h3>
<p>使用 systemd-networkd 的话需要确保 <code>/etc/resolv.conf</code> 是一个软链接，链接到 <code>/run/systemd/network/resolv.conf</code>。</p>
<h4>有线网络</h4>
<p>创建网络配置文件：</p>
<pre><code>nano -w /etc/systemd/network/20-wired.network
</code></pre>
<p>内容如下：</p>
<pre><code>[Match]
Name=enp1s0

[Network]
DHCP=yes
</code></pre>
<p>其中：</p>
<ul>
<li><code>enp1s0</code> 是无线网卡名，可以通过 <code>ip link</code> 查看得到</li>
</ul>
<p>开机启动联网：</p>
<pre><code>systemctl enable systemd-networkd.service
</code></pre>
<h4>无线网络</h4>
<p>安装、配置 wpa_passphrase：</p>
<pre><code>emerge --ask net-wireless/wpa_supplicant
wpa_passphrase MyNetwork SuperSecretPassphrase &gt; /etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf
systemctl enable wpa_supplicant@wlp2s0.conf
</code></pre>
<p>其中：</p>
<ul>
<li><code>wlp2s0</code> 是无线网卡名，可以通过 <code>ip link</code> 查看得到</li>
<li><code>MyNetwork</code> 是无线网络名</li>
<li><code>SuperSecretPassphrase</code> 是无限网络密码</li>
</ul>
<p>创建网络配置文件：</p>
<pre><code>nano -w /etc/systemd/network/25-wireless.network
</code></pre>
<p>内容如下：</p>
<pre><code>[Match]
Name=wlp2s0

[Network]
DHCP=yes
</code></pre>
<p>开机启动联网：</p>
<pre><code>systemctl enable systemd-networkd.service
</code></pre>
<h3>NetworkManager 联网</h3>
<p>最简单的联网方法就是用 NetworkManager，但是它比较重。</p>
<p>修改 <code>/etc/portage/make.conf</code> 的 <code>USE</code> 选项：</p>
<pre><code>USE=&quot;${USE} networkmanager&quot;
</code></pre>
<p>安装 NetworkManager：</p>
<pre><code>emerge --ask --deep --new-use @world
emerge --ask net-misc/networkmanager
</code></pre>
<p>修改普通用户组：</p>
<pre><code>usermod -a -G plugdev fu
</code></pre>
<p>开机启动 NetworkManager：</p>
<pre><code>systemctl enable NetworkManager
</code></pre>
<h3>更新环境</h3>
<pre><code>env-update &amp;&amp; source /etc/profile
</code></pre>
<h2>安装引导程序</h2>
<p>安装 UEFI 启动管理器：</p>
<pre><code>bootctl install
</code></pre>
<p>添加系统启动项：</p>
<pre><code>nano -w /boot/loader/entries/gentoo.conf
</code></pre>
<p>根据 <code>/boot</code> 内的 <code>vmlinuz</code> 和 <code>initramfs</code> 的文件名，设置内容如下：</p>
<pre><code>title Gentoo Linux
linux /vmlinuz-XXX
initrd /initramfs-XXX
options root=PARTUUID=XXXXXX rw init=/lib/systemd/systemd
</code></pre>
<p>其中：</p>
<ul>
<li><code>PARTUUID</code> 是通过 <code>blkid</code> 命令查看分区得到的</li>
</ul>
<p>调整启动管理器配置：</p>
<pre><code>nano -w /boot/loader/loader.conf
</code></pre>
<p>内容如下：</p>
<pre><code>default gentoo
timeout 1
</code></pre>
<h2>重启</h2>
<p>基本系统安装完毕，就可以作为服务器进行配置了。</p>
<pre><code>exit
reboot
</code></pre>
<h2>安装桌面系统</h2>
<pre><code>emerge --ask x11-base/xorg-server
emerge --ask x11-wm/i3
emerge --ask x11-terms/st

echo &quot;exec i3&quot; &gt; ~/.xinitrc
</code></pre>
<p>之后就用 <code>startx</code> 命令就可以进入 i3 图形窗口管理了。</p>
<h2>清理系统</h2>
<pre><code>rm /stage3-amd64-systemd-20211024T170536Z.tar.xz

emerge --depclean
emerge --ask app-portage/gentoolkit
eclean --deep distfiles
eclean --deep packages
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/gentoo/%E4%BD%A0%E5%A5%BD%EF%BC%81Gentoo.html</id>
    <title>你好！Gentoo</title>
    <updated>2021-10-03T17:27:11+08:00</updated>
    <published>2021-10-03T17:27:11+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/gentoo/%E4%BD%A0%E5%A5%BD%EF%BC%81Gentoo.html"/>
    <summary>家用 Archlinux 九年了， 工作开发也使用这个系统， 但 Archlinux 包滚动更新过于激进， 在服务器上选择了 CentOS， Linux 系统使用一直都很和谐。...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>家用 Archlinux 九年了，
工作开发也使用这个系统，
但 Archlinux 包滚动更新过于激进，
在服务器上选择了 CentOS，
Linux 系统使用一直都很和谐。</p>
<p>最近 CentOS 开始改变策略，
已经变得不适合服务器了，
于是开始考虑其他 Linux，
考察一番后，集中在三个发行版：</p>
<ul>
<li>Debian</li>
<li>NixOS</li>
<li>Gentoo</li>
</ul>
<p>使用过 Debian，发现一些不是很喜欢的特性：</p>
<ul>
<li>许多应用会被包装一层，配置和使用不与上游保持一致</li>
<li>有些应用安装后会默认启动，启动时又初始化一些默认数据</li>
</ul>
<p>这样自定义一些应用变得麻烦起来，随弃用 Debian。</p>
<p>Gentoo 和 NixOS 都能完美实现同一个应用多版本共存使用，
但是 NixOS 过于激进，弃用了 LFS 标准，包的数量不多，
官方文档不成熟，各应用的配置选项只能通过阅读 Nix 脚本源码来查看使用，
使用上各种不便。</p>
<p>各种抉择后，选择了 Gentoo，
它的 Portage 包管理系统无与伦比，
以至于 Gentoo 被称为元发行版。</p>
<p>Gentoo 几乎可以运行在任何 CPU 类型上，
使用范围极广，
唯一劣势就是基于源码编译安装，安装比较麻烦费时，
但正是由于源码编译安装，Gentoo 可以让你很容易掌控系统的方方面面，
再加上近来 CPU 性能提升、大内存和固态硬盘的普及，极大的缩短了编译时间，
这个劣势也得到了很大缓解。</p>
<p>最近打算先将家用计算机迁移到 Gentoo，认真学习一下 Gentoo 的 Portage 包管理系统，
总结为一系列博客，记录一下这个学习过程。</p>
<p>许久未写博客，感觉又在挖坑...</p>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/linux/command/linux%20command%E4%B9%8Bunar.html</id>
    <title>linux command之unar</title>
    <updated>2019-11-13T15:01:06+08:00</updated>
    <published>2019-11-13T15:01:06+08:00</published>
    <link href="https://fugangqiang.github.io/posts/linux/command/linux%20command%E4%B9%8Bunar.html"/>
    <summary>网上下载的一些 zip 文件通常在 linux 下解压会出现文件路径命乱码的问题，需要 `unar` 命令来解压...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <p>网上下载的一些 zip 文件通常在 linux 下解压会出现文件路径命乱码的问题，需要 <code>unar</code> 命令来解压</p>
<pre><code>pacman -S unarchiver
unar xxx.zip
</code></pre>

        ]]>
    </content>
  </entry><entry>
    <id>https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html</id>
    <title>rust并发编程：线程高级用法</title>
    <updated>2018-05-14T15:40:59+08:00</updated>
    <published>2018-05-14T15:40:59+08:00</published>
    <link href="https://fugangqiang.github.io/posts/rust/rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html"/>
    <summary>## Barrier...</summary>
    <content type="html" xml:lang="en" xml:base="https://fugangqiang.github.io">
        <![CDATA[
        <h2>Barrier</h2>
<p><code>Barrier</code> 可以让多个线程同时都执行到在某一点后才能一起再往后执行：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Barrier};

fn main() {
    let mut handles = Vec::with_capacity(10);
    let barrier = Arc::new(Barrier::new(10));

    for _ in 0..10 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!(&quot;before wait&quot;);
            b.wait();
            println!(&quot;after wait&quot;);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
</code></pre>
<p>上面程序会在所有线程都打印出 <code>before wait</code> 后，才会在继续运行，打印 <code>after wait</code>，
这样就保证了所有线程的 <code>after wait</code> 输出在 <code>before wait</code> 输出之后。</p>
<h2>Condition Variables</h2>
<p><code>Condition Variables</code> 通常和 <code>Mutex</code> 一起使用，可以让线程挂起，直到某个条件发生后才会让线程继续执行下去：</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let &amp;(ref lock, ref cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        println!(&quot;changing started&quot;);
        *started = true;
        cvar.notify_one();
    });

    let &amp;(ref lock, ref cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!(&quot;started changed&quot;);
}
</code></pre>
<p>上面程序中，如果 <code>started</code> 变量是 <code>false</code>，主线程进入 <code>while</code> 循环体，
并在循环体内释放 <code>started Mutex</code> 锁后挂起线程，直到在其他线程中调用 <code>cvar.notify_one</code> 方法来唤醒主线程，
然后再次利用 <code>while</code> 循环条件判断，直到 <code>started</code> 的值为 <code>true</code> 才会继续执行循环之后的代码。</p>
<h2>Call Once</h2>
<p>有时，多线程中，有些函数只允许被调用一次，通常这类函数是用来在线程间初始化一些全局变量的，
这样，无论哪个线程先调用这个函数，都会保证全局变量只会被初始化一次，
随后的其他线程的调用就忽略会这个函数体了。</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Once, ONCE_INIT};

static mut VAL: usize = 0;
static INIT: Once = ONCE_INIT;

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!(&quot;{}&quot;, unsafe { VAL });
}
</code></pre>
<p>上面程序运行结果取决于哪个线程第一次调用 <code>INIT.call_once</code>，
如果是 <code>handle1</code>，那么结果是 <code>1</code>，
如果是 <code>handle2</code>，那么结果是 <code>2</code>。</p>
<h2>线程局部变量</h2>
<p>rust 中用 <code>thread_local</code> 宏来初始化线程局部变量，并在线程内部用该变量的 <code>with</code> 方法来获取该变量值：</p>
<pre><code class="language-rust">use std::cell::RefCell;
use std::thread;

thread_local! {
    static FOO: RefCell&lt;u32&gt; = RefCell::new(1);
}

fn main() {
    FOO.with(|foo| {
        assert_eq!(*foo.borrow(), 1);
        *foo.borrow_mut() = 2;
    });

    // each thread starts out with the initial value of 1
    thread::spawn(move|| {
        FOO.with(|foo| {
            assert_eq!(*foo.borrow(), 1);
            *foo.borrow_mut() = 3;
        });
    });

    // we retain our original value of 2 despite the child thread
    FOO.with(|foo| {
        assert_eq!(*foo.borrow(), 2);
    });
}
</code></pre>

        ]]>
    </content>
  </entry>
</feed>
